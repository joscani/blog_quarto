{
  "hash": "159bbb168af56fb335cac830a82a65f5",
  "result": {
    "markdown": "---\ntitle: Mapeando\ndate: '2023-05-06'\ncategories: \n  - Estadística\n  - gis\n  - R\n  - 2023\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\n    code-fold: show\n    code-summary: \"Mostrar / ocultar código\"\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\neditor_options:\n  markdown:\n    wrap: none\nimage: \"\"\n---\n\n\nSiempre me ha gustado el tema de los Sistemas de información geográfica y derivados. Ya cuando trabajaba en el [IESA](https://www.iesa.csic.es/) fui a un curso en Vigo sobre [gvSIG](http://www.gvsig.com/es) y luego aprendí cosas con [QGIS](https://www.qgis.org/es/site/) , el cual me sigue pareciendo un software más que excelente.\n\nHoy en día se pueden hacer muchísimas cosas con Python y con R, incluso tienen conectores con librerías de javascript para hacer cosas resultonas y con interactividad, veáse [esto](https://r-graph-gallery.com/map.html) por ejemplo. En realidad tanto python como R tiran de las mismas librerías de bajo nivel, a saber, `gdal`, `libproj`, `libgeos` y similares, las cuales, para ser honestos, pueden meterte en un infierno de dependencias en según qué sistemas unix. Eso sí, una vez sales de ahí es una gozada.\n\nTotal, el caso es que el pasado jueves me llega una duda del gran [Leonardo Hansa](https://www.linkedin.com/in/analisisdedatos/), que reproduzco a continuación.\n\n\n>Vicepresi, tú sabes cómo se puede saber si dos códigos postales son adyancentes? Con datos, claro, no a ojo\n\nY bueno, como no tenía mucho más que hacer esa tarde y soy un picado de la vida, pues me dije. \n\n> Creo que tengo un shapefile de códigos postales de 2019 que no recuerdo como llegó a mis manos, quizá pueda hacer algo. \n\n\n\nY me puse manos a la obra a investigar a ver cómo se podría hacer eso de encontrar polígonos adyacentes a uno dado usando `Rstats`. El caso es que llegué  a varios hilos dónde se comentaban diferentes formas, una era usando la función `poly2nb`  de la librería `spdep` y también cómo hacerlo usando la función `st_intersects` de la librería `sf` . En este [`issue`](https://github.com/r-spatial/sf/issues/234) incluso comentaban los grandes de estas cosas, Edzer Pebesma , Roger Bivand y nuestro conocico Virgilio Gómez Rubio. \n\n\nBueno, vamos al código, que de eso se trata. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\n\nmapa <- st_read(here::here(\"data/shapefiles/cod_postales/cp_19_dis.shp\"))\n#> Reading layer `cp_19_dis' from data source \n#>   `/media/hd1/canadasreche@gmail.com/blog_quarto/data/shapefiles/cod_postales/cp_19_dis.shp' \n#>   using driver `ESRI Shapefile'\n#> Simple feature collection with 10809 features and 4 fields (with 1 geometry empty)\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -2021660 ymin: 3203377 xmax: 481778.5 ymax: 5433002\n#> Projected CRS: WGS 84 / Pseudo-Mercator\n\nhead(mapa)\n#> Simple feature collection with 6 features and 4 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -1536953 ymin: 3373964 xmax: -41802.13 ymax: 5247186\n#> Projected CRS: WGS 84 / Pseudo-Mercator\n#>      cp cp_num cp_2 cp_2_num                       geometry\n#> 1 35560  35560   35       35 MULTIPOLYGON (((-1518970 33...\n#> 2 27330  27330   27       27 MULTIPOLYGON (((-821864.3 5...\n#> 3 46680  46680   46       46 MULTIPOLYGON (((-51610.46 4...\n#> 4 49706  49706   49       49 MULTIPOLYGON (((-641488.4 5...\n#> 5 21120  21120   21       21 MULTIPOLYGON (((-776955.2 4...\n#> 6 16623  16623   16       16 MULTIPOLYGON (((-256256.7 4...\n```\n:::\n\n\nPinto códigos postales de la provincia de Madrid por ejemplo, coloreando por área de cada polígono.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapa |>\n    \n    # calculo area usando st_area\n    mutate(area_m2 = st_area(mapa) |> \n               as.numeric()) |>\n    filter(cp_2 == 28) |>\n    ggplot() +\n    geom_sf(aes(fill = area_m2)) +\n    scale_fill_viridis_c()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=80%}\n:::\n:::\n\n\nPara encontrar los polígonos adyacentes uso `st_intersects` que permite por ejemplo saber qué puntos están dentro de un polígono y cosas así. Al aplicarlo sobre una geometría de tipo polígono lo que encuentra son los polígonos adyacentes. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mido a ver cuánto tarda. \ntictoc::tic()\nlista_adyacentes <- st_intersects(mapa)\ntictoc::toc()\n#> 2.121 sec elapsed\n```\n:::\n\n\nAhora si quisiera saber qué polígonos son adyacentes a uno dado, es simplemente seleccionar en lista adyacentes, por ejemplo \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlista_adyacentes[1]\n#> [[1]]\n#> [1]    1 3684 4621 6345 7017 7996\n```\n:::\n\n\nPara ver los adyacentes a mi código postal en Madrid. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(fila_mi_cp <-  mapa |> \n    rownames_to_column() |> \n    filter(cp == \"28043\") |> \n    pull(rowname))\n#> [1] \"9138\"\n\n\n(mis_vecinos_fila <- lista_adyacentes[as.numeric(fila_mi_cp)])\n#> [[1]]\n#> [1]  493 4831 4998 5127 6941 7662 9138 9427\n```\n:::\n\nPero me devuelve el número de fila, para ver el cp sería \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_cp <-  \"28043\"\n(mis_vecinos <- mapa$cp[mis_vecinos_fila[[1]]])\n#> [1] \"28028\" \"28042\" \"28002\" \"28022\" \"28033\" \"28016\" \"28043\" \"28027\"\n\n(adyacentes <-  setdiff(mis_vecinos, mi_cp))\n#> [1] \"28028\" \"28042\" \"28002\" \"28022\" \"28033\" \"28016\" \"28027\"\n```\n:::\n\n\nPintamos\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  mapa |> \n    filter(cp_2 == 28) |>\n        mutate(\n            tipo = case_when(\n                cp == mi_cp ~ \"mi_cp\", \n                cp %in% adyacentes ~ \"mis_copostales_vecinos\", \n                TRUE ~ \"resto de codpostales\"\n            )\n        ) |> \n        ggplot() +\n        geom_sf(aes(fill = tipo)) +\n        scale_fill_viridis_d()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=80%}\n:::\n:::\n\n\ny listo.. \nLo ponemos en unas funcioncitas todo \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_adyacentes <- function(mapa = mapa, id_col = \"cp_num\") {\n  \n  # quiza sacar el st_intersects de la función sea mejor\n  nb <-  st_intersects(mapa)\n  \n  get_nb <-  function(x){\n      res <- mapa[[id_col]][x]\n      res\n  }\n  \n  adjacency_list <-  lapply(nb, get_nb)\n  adjacency_list_names <-  mapa[[id_col]][1:length(adjacency_list)]\n  names(adjacency_list) <- adjacency_list_names\n  adjacency_list\n}\n\n\n\n\nget_mis_vecinos <-  function(mi_cp, cps_adyacentes){\n    cp_simbol <-  as.symbol(mi_cp) # a simbolo para poder llamara cps_adyacentes[[`18814`]]\n    mis_vecinos <-  cps_adyacentes[[cp_simbol]]\n}\n\n\n\n# mapa seleccionando solo tu provincia \n\n\nplot_cp_vecinos <-  function(mi_cp, cps_adyacentes, mapa){\n    cp_simbol <-  as.symbol(mi_cp)\n    mis_vecinos <-  cps_adyacentes[[cp_simbol]]\n    mi_prop <-  stringr::str_sub(mi_cp, 1, 2) |> as.numeric()\n    adyacentes <-  setdiff(mis_vecinos, mi_cp)\n    mapa |> \n        filter(cp_2_num == mi_prop) |> \n        mutate(\n            tipo = case_when(\n                cp_num == mi_cp ~ \"mi_cp\", \n                cp_num %in% adyacentes ~ \"mis_copostales_vecinos\", \n                TRUE ~ \"resto de codpostales\"\n            )\n        ) |> \n        ggplot() +\n        geom_sf(aes(fill = tipo)) +\n        scale_fill_viridis_d()\n}\n```\n:::\n\n\n\n\nY ya podemos usarlo\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncps_adyacentes <-  get_adyacentes(mapa, id_col = \"cp_num\")\n\n(mis_cps_vecinos_pueblo <- get_mis_vecinos(18814, cps_adyacentes))\n#> [1] 18815 18800 18817 18811 18814 18818 18816\n```\n:::\n\n\n\nPintamos \n\n::: {.cell}\n\n```{.r .cell-code}\n\nplot_cp_vecinos(18814, cps_adyacentes, mapa) +\n    labs(title = \"CP núcleo principal Cortes de Baza\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=80%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# plaza cascorro\n\nplot_cp_vecinos(28005, cps_adyacentes, mapa) +\n    labs(title = \"cp Plaza Cascorro\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=80%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pongo Carmona por ser el de mayor área \n\n(get_mis_vecinos(41410, cps_adyacentes))\n#>  [1] 41620 41300 41449 41339 41420 41359 41610 41600 41320 41309 41520 41429\n#> [13] 41410 41510 41310 41016 41500 41440\n\nplot_cp_vecinos(41410, cps_adyacentes, mapa) +\n    labs(title= \"Carmona\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=80%}\n:::\n:::\n\n## Notas\n\n* Los códigos postales que uso están desactualizados. La capa de shapefile es un producto que vende Correos a precio no barato. Antes se podían descargar de CartoCiudad, pero ya no. Algún enlace interesante: \n    * [post de Raúl Vaquerizo](https://analisisydecision.es/como-hacer-un-mapa-de-espana-por-codigos-postales-con-qgis/)\n    * [post de nosolosig](https://www.nosolosig.com/articulos/1191-asi-hice-el-mapa-de-los-codigos-postales-de-espana-con-sig-y-datos-abiertos)\n* Libros online sobre GIS en R:\n    * [r-spatial](https://r-spatial.org/book/) \n    * [geocomputation with R](https://r.geocompx.org/index.html)\n    \n* [Applied Spatial Data Analysis with R](https://asdar-book.org/) . Un poco antiguo ya, no sé si Virgilio, Roger y Edzer están trabajando sobre nueva edición o no\n    \n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}