{
  "hash": "a9662c40e033390c6d11556e1cc9fa5c",
  "result": {
    "markdown": "---\ntitle: Cachitos. Segunda parte\nauthor: jlcr\ndate: '2022-01-10'\nslug: cachitos-segunda-parte\ncategories:\n  - estadística\n  - polémica\n  - 2022\n  - textmining\n  - ocr\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\nNada, esto es sólo para leernos con R los subtítulos del post anterior. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nroot_directory = \"/media/hd1/canadasreche@gmail.com/public/proyecto_cachitos/\"\nanno <- \"2021\"\n\n# Construims un data frame con los nombrs de los ficheros \n\nnombre_ficheros <- list.files(path = str_glue(\"{root_directory}{anno}_txt/\")) %>% \n    enframe() %>% \n    rename(n_fichero = value)\n\nnombre_ficheros\n#> # A tibble: 1,384 × 2\n#>     name n_fichero                     \n#>    <int> <chr>                         \n#>  1     1 00000001.jpg.subtitulo.tif.txt\n#>  2     2 00000002.jpg.subtitulo.tif.txt\n#>  3     3 00000003.jpg.subtitulo.tif.txt\n#>  4     4 00000004.jpg.subtitulo.tif.txt\n#>  5     5 00000005.jpg.subtitulo.tif.txt\n#>  6     6 00000006.jpg.subtitulo.tif.txt\n#>  7     7 00000007.jpg.subtitulo.tif.txt\n#>  8     8 00000008.jpg.subtitulo.tif.txt\n#>  9     9 00000009.jpg.subtitulo.tif.txt\n#> 10    10 00000010.jpg.subtitulo.tif.txt\n#> # … with 1,374 more rows\n```\n:::\n\n\nAhora los podemos leer en orden\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtitulos <-  list.files(path = str_glue(\"{root_directory}{anno}_txt/\"), \n                        pattern = \"*.txt\", full.names = TRUE) %>% \n    map(~read_file(.)) %>% \n    enframe() %>%  \n  # hacemos el join con el dataframe anterior para tener el nombre del fichero original\n    left_join(nombre_ficheros)\n\nglimpse(subtitulos)\n#> Rows: 1,384\n#> Columns: 3\n#> $ name      <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…\n#> $ value     <list> \"\\f\", \"\\f\", \"FUN MÚSICA Y CINTAS DE VÍDEO\\n\\f\", \" \\n\\f\", \"\\…\n#> $ n_fichero <chr> \"00000001.jpg.subtitulo.tif.txt\", \"00000002.jpg.subtitulo.ti…\nsubtitulos\n#> # A tibble: 1,384 × 3\n#>     name value     n_fichero                     \n#>    <int> <list>    <chr>                         \n#>  1     1 <chr [1]> 00000001.jpg.subtitulo.tif.txt\n#>  2     2 <chr [1]> 00000002.jpg.subtitulo.tif.txt\n#>  3     3 <chr [1]> 00000003.jpg.subtitulo.tif.txt\n#>  4     4 <chr [1]> 00000004.jpg.subtitulo.tif.txt\n#>  5     5 <chr [1]> 00000005.jpg.subtitulo.tif.txt\n#>  6     6 <chr [1]> 00000006.jpg.subtitulo.tif.txt\n#>  7     7 <chr [1]> 00000007.jpg.subtitulo.tif.txt\n#>  8     8 <chr [1]> 00000008.jpg.subtitulo.tif.txt\n#>  9     9 <chr [1]> 00000009.jpg.subtitulo.tif.txt\n#> 10    10 <chr [1]> 00000010.jpg.subtitulo.tif.txt\n#> # … with 1,374 more rows\n```\n:::\n\nen n_fichero tenemos el nombre y en value el texto\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nsubtitulos %>% \n  pull(value) %>%\n  ## usamos `[[` que es el operador para acceder a la lista el que normalemente se usa [[nombre_elemento]]\n  `[[`(16)\n#> [1] \"Ella resume a la perfección la filosofía de Cachitos:\\nmontar “La fiesta” “Buscando en el baúl de los recuerdos”.\\n\\n \\n\\f\"\n\n# equivalentemente\n\n# subtitulos %>% \n#     pull(value) %>% \n#     pluck(16)\n\n```\n:::\n\n\nComo sabemos que hay muchos ficheros sin texto podemos contar letras. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtitulos <- subtitulos %>% \n    mutate(n_caracteres = nchar(value)) \n\nsubtitulos %>% \n    group_by(n_caracteres) %>% \n    count()\n#> # A tibble: 128 × 2\n#> # Groups:   n_caracteres [128]\n#>    n_caracteres     n\n#>           <int> <int>\n#>  1            1   428\n#>  2            3    97\n#>  3            4    19\n#>  4            5    13\n#>  5            6    15\n#>  6            7     8\n#>  7            8     6\n#>  8            9     3\n#>  9           10     3\n#> 10           11     2\n#> # … with 118 more rows\n\nsubtitulos %>% \n    group_by(n_caracteres) %>% \n    count() %>% \n  ggplot(aes(x = n_caracteres, y = n)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=80%}\n:::\n:::\n\n\nY vemos que hay muchos subtitulos con pocos caracteres. Si vemos por ejemplo los que tienen menos de 12 caracteres\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtitulos %>% \n    filter(n_caracteres <12) %>% \n    pull(value) %>% \n    head(10)\n#> [[1]]\n#> [1] \"\\f\"\n#> \n#> [[2]]\n#> [1] \"\\f\"\n#> \n#> [[3]]\n#> [1] \" \\n\\f\"\n#> \n#> [[4]]\n#> [1] \"\\f\"\n#> \n#> [[5]]\n#> [1] \" \\n\\f\"\n#> \n#> [[6]]\n#> [1] \" \\n\\f\"\n#> \n#> [[7]]\n#> [1] \"\\f\"\n#> \n#> [[8]]\n#> [1] \"\\f\"\n#> \n#> [[9]]\n#> [1] \"\\f\"\n#> \n#> [[10]]\n#> [1] \"\\f\"\n```\n:::\n\n\nQue se corresponden con haber pillado parte no del subtítulo sino del nombre de la actuación\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtitulos %>% \n    filter(n_caracteres ==15)\n#> # A tibble: 2 × 4\n#>    name value     n_fichero                      n_caracteres\n#>   <int> <list>    <chr>                                 <int>\n#> 1   571 <chr [1]> 00000571.jpg.subtitulo.tif.txt           15\n#> 2  1361 <chr [1]> 00001361.jpg.subtitulo.tif.txt           15\n```\n:::\n\n\nUsando la librería `magick` en R que permite usar `imagemagick` en R, ver **[post](https://analisisydecision.es/tratamiento-y-procesado-de-imagenes-con-r-y-magick/)** de Raúl Vaquerizo y su homenaje a Sean Connery, podemos ver el fotgrama correspondiente\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magick)\n(directorio_imagenes <- str_glue(\"{root_directory}video/{anno}_jpg/\"))\n#> /media/hd1/canadasreche@gmail.com/public/proyecto_cachitos/video/2021_jpg/\n\nimage_read(str_glue(\"{directorio_imagenes}00000018.jpg\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=80%}\n:::\n:::\n\n\nTambién podemos ver hasta cuando pasa eso, por ejemplo si vemos subtítulos con 18 caracteres\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtitulos %>% \n    filter(n_caracteres ==18) %>% \n    pull(value)\n#> [[1]]\n#> [1] \" \\n\\nJ0 EN EL AMOR\\n\\f\"\n#> \n#> [[2]]\n#> [1] \"¿EDITH BROOKS\\nch\\n\\f\"\n#> \n#> [[3]]\n#> [1] \" \\n\\nmme Tha Power\\n\\f\"\n#> \n#> [[4]]\n#> [1] \"  \\n\\n\\\"RONTERA\\n\\n  \\n\\f\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtitulos <- subtitulos %>% \n    filter(n_caracteres > 17) \n\nglimpse(subtitulos)\n#> Rows: 778\n#> Columns: 4\n#> $ name         <int> 3, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 27, 28, 29, 30…\n#> $ value        <list> \"FUN MÚSICA Y CINTAS DE VÍDEO\\n\\f\", \"El servicio meteoro…\n#> $ n_fichero    <chr> \"00000003.jpg.subtitulo.tif.txt\", \"00000014.jpg.subtitulo…\n#> $ n_caracteres <int> 30, 118, 82, 117, 117, 25, 100, 97, 86, 88, 84, 43, 52, 8…\n```\n:::\n\n\n\n\nCon el fin de detectar cuáles están duplicados y aprovechando que están en orden de aparición, podemos hacer utilizar distancias de texto para calcular la distancia de cada subtítulo con el anterior, y si la distancia es pequeña es que es el mismo rótulo. \n\nPrimero hacemos una mini-limpieza. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring_mini_clean <-  function(string){\n    string <- gsub(\"?\\n|\\n\", \" \", string)\n    string <- gsub(\"\\r|?\\f|=\", \" \", string)\n    string <- gsub('“|”|—|>',\" \", string)\n    \n    string <- gsub(\"[[:punct:][:blank:]]+\", \" \", string)\n    string <- tolower(string)\n    string <- gsub(\"  \", \" \", string)\n    \n    return(string)\n}\n\n# Haciendo uso de programacion funciona con purrr es muy fácil pasar esta función a cada elemento. y decirle que # el reultado es string con map_chr\n\nsubtitulos_proces <- subtitulos %>% \n    mutate(texto = map_chr(value, string_mini_clean)) %>% \n    select(-value)\n\nsubtitulos_proces %>% \n  select(texto)\n#> # A tibble: 778 × 1\n#>    texto                                                                        \n#>    <chr>                                                                        \n#>  1 \"fun música y cintas de vídeo \"                                              \n#>  2 \"el servicio meteorológico de cachitos informa se prevén vientos de fiesta m…\n#>  3 \"no es para menos llevamos dos años conformándonos solo con aires de siesta \"\n#>  4 \"ella resume a la perfección la filosofía de cachitos montar la fiesta busca…\n#>  5 \" ella resume a la perfección la filosofía de cachitos montar la fiesta busc…\n#>  6 \" oncé a2y in love \"                                                         \n#>  7 \"esperamos que tengáis una tele bien grande no sabemos si cabrá tanto flow e…\n#>  8 \"liberté egalité fraternité vacunaté y beyoncé la lola flores negra ejercien…\n#>  9 \"mirad su pelo ya os dijimos que el aire de fiesta iba a soplar fuerte esta …\n#> 10 \"mirad su pelo ya os dijimos que el aire de fiesta iba a soplar fuerte esta …\n#> # … with 768 more rows\n```\n:::\n\n\nY ya vemos a simple vista que hay algun duplicado. Calculemos ahora la distancia de strings, utilizando la función `stringdist` de la librería del mismo nombre.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nsubtitulos_proces %>% \n    mutate(texto_anterior = lag(texto)) %>% \n    # calculamos distancias con método lcs (que no me he leído que hace exactamente)\n    mutate(distancia = stringdist::stringdist(texto, texto_anterior, method = \"lcs\")) %>% \n  # veamos algunos elementos\n    filter(distancia < 19) %>% \n    arrange(desc(distancia) ) %>% \n    select(texto, texto_anterior, distancia) \n#> # A tibble: 89 × 3\n#>    texto                                                         texto…¹ dista…²\n#>    <chr>                                                         <chr>     <dbl>\n#>  1 \" la rosalía emérita \"                                        \" alía…      18\n#>  2 \"chango llegó a españa como aspirante a estrella del rock y … \"chang…      15\n#>  3 \"leonard cohen y el pitufo gruñón en el cuerpo de un italian… \"leona…      13\n#>  4 \" el stress del año 2000 nos llegó con casi 20 os de retraso… \" el s…       7\n#>  5 \"aquí ya llevaba cuatro años de carrera luis miguel tiene má… \"aquí …       7\n#>  6 \"imborrable siempre la sonrisa de jerry aunque un poco incóm… \"la im…       6\n#>  7 \"7 literalmente significa puedes tocarme la campanita funcio… \"liter…       6\n#>  8 \" las palabras no vienen fácilmente paradójicamente no fue e… \" las …       5\n#>  9 \"en españa el g arm nació ya vintage porque el británico nos… \"en es…       5\n#> 10 \"nosotros también lo sentimos si alguien se ofende y en nues… \" 4 no…       5\n#> # … with 79 more rows, and abbreviated variable names ¹​texto_anterior,\n#> #   ²​distancia\n```\n:::\n\n\nY parece que funciona. \nAsí que decido quitar las filas dónde la distancia  sea menos que 19  y así eliminar muchos de los duplicados. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubtitulos_proces <- subtitulos_proces %>% \n    mutate(texto_anterior = lag(texto)) %>% \n    mutate(distancia = stringdist::stringdist(texto, texto_anterior, method = \"lcs\")) %>% \n    filter(distancia > 19) %>% \n    select(-texto_anterior)\n\nsubtitulos_proces %>% \n  head()\n#> # A tibble: 6 × 5\n#>    name n_fichero                      n_caracteres texto                dista…¹\n#>   <int> <chr>                                 <int> <chr>                  <dbl>\n#> 1    14 00000014.jpg.subtitulo.tif.txt          118 \"el servicio meteor…     106\n#> 2    15 00000015.jpg.subtitulo.tif.txt           82 \"no es para menos l…     110\n#> 3    16 00000016.jpg.subtitulo.tif.txt          117 \"ella resume a la p…     102\n#> 4    18 00000018.jpg.subtitulo.tif.txt           25 \" oncé a2y in love \"     100\n#> 5    19 00000019.jpg.subtitulo.tif.txt          100 \"esperamos que teng…      92\n#> 6    20 00000020.jpg.subtitulo.tif.txt           97 \"liberté egalité fr…     105\n#> # … with abbreviated variable name ¹​distancia\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(subtitulos_proces,\n          file = str_glue(\"{root_directory}{anno}_txt_unido.csv\"))\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}