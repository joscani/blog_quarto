{
  "hash": "698b400e23ce8b7b930ede2850b1d2be",
  "result": {
    "markdown": "---\ntitle: Palabras para Julia ( Parte 3/n)\nauthor: jlcr\ndate: '2022-03-20'\nslug: palabras-para-julia-parte-3-n\ncategories:\n  - Julia\n  - R\n  - Stan\n  - análisis bayesiano\n  - 2022\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n---\n\n\nTengo una relación extraña con Julia, por un lado me gusta bastante y por otro me parece que aún le falta algo para que lo adopte de forma más seria. Quizá tenga que ver con mi forma de aprender (que seguro que no es óptima), en vez de irme a los tutoriales típicos, me voy directamente a ver cómo se hace algo que me interesa. En este caso hacer modelos bayesianos con Julia usando [Turing](https://turing.ml/stable/).\n\nTuring es una librería escrita en Julia para programación probabilística, podría considerarse como un competidor de [Stan](https://mc-stan.org/), aunque todavía es una librería joven. Turing añade sólo una pequeña capa de programación probabilística, y promete cosas como  modelos de redes neuronales dónde los pesos sigan una distribución probabilística\n\nNo me voy a meter en esos lares, yo soy más prosaico y por el momento sólo quiero ejemplificar con Turing el modelo que cuento en [pluralista](https://muestrear-no-es-pecado.netlify.app/2022/02/06/pluralista/).\n\nRecordemos que habías simulado unos datos tal que así.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1908)\nN <- 1000 # número de pares, 1000 madres y 1000 hijas\n\n\nU <- rnorm(N,0,1) # Simulamos el confounder\n\n# orden de nacimiento y \nB1 <- rbinom(N,size=1,prob=0.5)  # 50% de madres nacieeron en primer lugar\nM <- rnorm( N , 2 * B1 + U )\n\nB2 <- rbinom(N,size=1,prob=0.5) # 50% son las primogénitas\nD <- rnorm( N , 2  *B2 + U + 0 * M )\n```\n:::\n\n\nEn la simulación se ha forzado que el efecto del número de hijos de la madre (M) sobre el número de hijos de la hija (D) sea cero.\n\n\nEl DAG era algo así. En este dag para estimar el efecto de M sobre D, hace falta condicionar por U, pero al ser una variable de confusión no observada, no habría forma de estimarlo de la forma tradicional (a lo Pearl).\nLa solución es estimar el DAG completo.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=80%}\n:::\n:::\n\n\n## Ajuste en Turing\n\nRecordemos que nuestra U es una variable que no tenemos, se podría asimilar a una variable con todos sus valores perdidos y cada uno de esos  valores perdidos es un parámetro a estimar.\n\n__Librerías__ : Aparte de Turing, hace falta ReverseDiff (diferenciación automática) y alguna más. \n\n\n```julia\nusing LinearAlgebra, Plots\nusing Turing\nusing ReverseDiff, Memoization \nusing DataFrames\nusing CSV\nusing Random\nusing StatsPlots\nusing Distributions\n\n```\n\nLeo los datos simulados que había guardado en un csv previamente\n\n```julia\n\npl = DataFrame(CSV.File(\"data/pluralista.csv\"))\ndescribe(pl)\n\n```\n\n```bash\njulia> describe(pl)\n4×7 DataFrame\n Row │ variable  mean     min       median    max      nmissing  eltype   \n     │ Symbol    Float64  Real      Float64   Real     Int64     DataType \n─────┼────────────────────────────────────────────────────────────────────\n   1 │ D         1.00621  -3.55365  0.986136  6.03293         0  Float64\n   2 │ M         1.00836  -3.91626  0.90395   6.69591         0  Float64\n   3 │ B1        0.473     0        0.0       1               0  Int64\n   4 │ B2        0.487     0        0.0       1               0  Int64\n\n```\n\nNos construimos el modelo con Turing.\n\nAlgunas cosas a comentar. \n\n- El uso de filldist para crear el vector de U y que cada valor siga una Normal(0,1).\n\n- `.+` para sumar un escalar como a1 con un vector. El uso del \".operacion\" es habitual en julia para hacer broadcast.\n\n-  MvNormal al final. Esto lo he leído por ahí para que haga mejor el sampleo.\n\n- Al igual que en Stan se tiene que escribir en cierto orden (y si no no funciona bien) porque Turing no es declarativo.\n\n```julia\n@model function pluralista(D, M, B1, B2)\n\n    N = Int(length(D))\n\n    # Variable no observada\n    U ~ filldist(Normal(0, 1), N)\n\n\n    # Prior coeficientes\n    a1 ~ Normal(0, 0.5)\n    a2 ~ Normal(0, 0.5)\n    m  ~ Normal(0, 0.5)\n    b  ~ Normal(0, 0.5)\n    p  ~ Beta(2,2)\n    \n    \n    k ~  Exponential(1)\n    σ₁ ~ Exponential(1)\n    σ₂ ~ Exponential(1)\n    \n    B1 ~ Bernoulli(p)\n    B2 ~ Bernoulli(p)\n    \n    #  transformed parameters\n    mu1 = a1 .+ b * B1 + k * U\n    mu2 = a2 .+ b * B2 + m * M + k * U\n    \n    # likelihood\n\n\n    M ~ MvNormal(mu1, σ₁ * I) \n    D ~ MvNormal(mu2, σ₂ * I)\n\nend\n```\n\nComparando con el código del mismo modelo en Stan (al final del post) se observa que la sintaxis es parecida. \n\n\n\n## Muestreo de la posterior en Turing\n\nHay que usar reversediff porque si no no acaba nunca.\n\n```julia\nRandom.seed!(155)\n\n\nTuring.setadbackend(:reversediff)\nTuring.setrdcache(true)\n\nflbi = sample(\n    pluralista(pl.D, pl.M, pl.B1, pl.B2), \n    NUTS(1000, 0.65),\n    MCMCThreads(),\n    2_000, 4)\n```\n\n```bash\njulia> flbi = sample(\n           pluralista(pl.D, pl.M, pl.B1, pl.B2), \n           NUTS(1000, 0.65),\n           MCMCThreads(),\n           2_000, 4)\n┌ Info: Found initial step size\n└   ϵ = 0.0125\n┌ Info: Found initial step size\n└   ϵ = 0.025\n┌ Info: Found initial step size\n└   ϵ = 0.05\n┌ Info: Found initial step size\n└   ϵ = 0.00625\n\nChains MCMC chain (2000×1020×4 Array{Float64, 3}):\n\nIterations        = 1001:1:3000\nNumber of chains  = 4\nSamples per chain = 2000\nWall duration     = 136.29 seconds\nCompute duration  = 510.14 seconds\n```\n\nY ha tardado unos 2 minutos por cadena. Ciertamente no está mal, pero no se acerca a la velocidad de Stan, que lo hace en unos 18 segundos.\n\nY podemos extraer un resumen de los parámetros que nos interesan con\n\n```bash\njulia> summarize(flbi[[:a1, :a2, :b, :m, :σ₁, :σ₂]])\nSummary Statistics\n  parameters      mean       std   naive_se      mcse         ess      rhat   ess_per_sec \n      Symbol   Float64   Float64    Float64   Float64     Float64   Float64       Float64 \n\n          a1    0.0682    0.0538     0.0006    0.0009   3268.9064    1.0007        6.4079\n          a2    0.0326    0.0759     0.0008    0.0024   1015.7923    1.0059        1.9912\n           m    0.0063    0.0430     0.0005    0.0018    554.1348    1.0096        1.0862\n           b    1.9865    0.0593     0.0007    0.0012   2403.5462    1.0008        4.7116\n          σ₁    1.1427    0.1205     0.0013    0.0049    535.2307    1.0086        1.0492\n          σ₂    0.9621    0.0719     0.0008    0.0016   2496.8176    1.0009        4.8944\n          \n```\n\nY efectivamente, lo ha hecho bien y ha recuperado los verdaderos valores de los parámetros y estimado que el efecto de M sobre D es 0.\n\n```julia\nmyplot = plot(flbi[[:a1, :a2, :b, :m, :σ₁, :σ₂]])\n\nsavefig(myplot,\"plurarlista_turing.png\")\n```\n\n\n![imagen](plurarlista_turing.png)\n\n\n## Reflexiones.\n\n-   Me ha parecido fácil escribir un modelo bayesiano como este en Turing\n-   No he conseguido ver como hacer que me funcione un predict sobre nuevos datos que tengan B1 y B2, pero no M y D. Cuestión de empezar más poco a poco con los tutoriales que hay por ahí.\n-   Por el momento parece que Stan sigue siendo el estado del arte en estas cosas, aunque lo de integrar Turing con [Flux](https://turing.ml/dev/tutorials/03-bayesian-neural-network/) por ejemplo, promete.\n\n\nMismo modelo en Stan. \n\n```stan\n\ndata{\n    int N;\n    vector[N] D;\n    vector[N] M;\n    int B1[N];\n    int B2[N];\n}\n\n\nparameters{\n    vector[N] U;\n    real m;\n    real b;\n    real a2;\n    real a1;\n    real<lower=0> tau;\n    real<lower=0> sigma;\n    real<lower=0> k;\n    real<lower=0,upper=1> p;\n}\n\ntransformed parameters {\n  vector[N] nu;\n  vector[N] mu;\n\n\n  for ( i in 1:N ) {\n        nu[i] = a2 + b * B2[i] + m * M[i] + k * U[i];\n    }\n    \n  for ( i in 1:N ) {\n        mu[i] = a1 + b * B1[i] + k * U[i];\n    }\n\n\n}\n\nmodel{\n    \n    U ~ normal( 0 , 1 );\n    \n    a1 ~ normal( 0 , 0.5 );\n    a2 ~ normal( 0 , 0.5 );\n    m  ~ normal( 0 , 0.5 );\n    b  ~ normal( 0 , 0.5 );\n    p  ~ beta( 2 , 2 );\n    \n    k ~ exponential( 1 );\n    sigma ~ exponential( 1 );\n    tau   ~ exponential( 1 );\n    B2    ~ bernoulli( p );\n    B1    ~ bernoulli( p );\n\n    D ~ normal( nu , tau );\n    M ~ normal( mu , sigma );\n}\n\n// genero point_loglikelihood, util para evaluar modelo con psis loo\ngenerated quantities {\n vector[N] log_lik_D;\n vector[N] log_lik_M;\n\n  for (i in 1:N)\n    log_lik_D[i] = normal_lpdf(D[i] | nu[i], tau);\n\n  for (i in 1:N)\n    log_lik_M[i] = normal_lpdf(M[i] | mu[i], sigma);\n\n\n  }\n\n```\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}