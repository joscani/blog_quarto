{
  "hash": "ec4d498d944ea97c34f0126e4f05dd7c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Orbital.¿Ayuda en entornos hostiles?\"  \ndate: '2024-11-16'\ncategories: \n  - \"2024\"\n  - tidymodels\n  - sql\n  - machine learning\n  - R\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\n  output: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8\n    fig-align: center\n    code-fold: show\n    code-link: true\n    code-summary: \"Show the code\"\n    code-tools: true \nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    comment: \"#>\"\nimage: 'orbital.webp'\n---\n\n\n\n::: callout-note\n## Listening\n\n\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/track/1ZLtE9tSJdaUiIJ9YoKHQe?utm_source=generator\" width=\"100%\" height=\"250\" frameBorder=\"0\" allowfullscreen=\"\" allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\"></iframe>\n\n\n:::\n\n\n## Introducción\n\nNo es raro encontrarse en entornos hostiles. Los que usamos R lo sabemos bien, es una batalla\nconstante, que en gran parte tiene que ver con el desconocimiento y otras con la maldad. \n\n\n## Hacer cosas en la BD. \n\nDesde los tiempos de PL/SQL anda por ahi el runrun de hacer cosas en la BD.  El caso típico es hacer\nlas transformaciones de filtrado, selección, creación de columnas y joins que hacemos en lenguajes\ncomo R, pero en la base de datos. Esto hace ya tiempo que está solucionando gracias a cosas como\n`dbplyr` y similar. De hecho, la filosofía de hazlo con una sintaxis sencilla en el frontend pero\nque el backend pueda cambiar se ha exportado de R a otras tecnologías, esa eRgonomía se ve por\nejemplo en `ibis` o `polars`. \n\nOtro caso más complicado es el de tener un modelo que se ha ajustado previamente y queremos usarlo\npara obtener predicciones. En estos casos salvo que estemos en cosas como spark o similar lo que se\nsuele hacer es bajar los datos de la BD, usar el modelo, obtener predicciones y subir los resultados \na la BD. A veces es un proceso batch o un docker u otra cosa rara, pero básicamente es eso. \n\nSe me olvidaba que en caso de ser un modelo simple de regresión o regresión logística siempre puede\nuno escribir la función obtenida en forma de `sql` y tirar millas. Pero en otro tipo de modelos es\nun poco más complejo. \n\nEn las [jornadas de R en Sevilla](https://www.imus.us.es/congresos/IIIRqueR/) que acaban de\nterminar, Hannah Frick de Posit nos contó lo [nuevo de tidymodels](https://hfrick.github.io/2024-3RqueR/#/title-slide) \ny aquí es dónde entran un par de librerías, `tidypredict` y `orbital`, la primera permite \"traducir\"\nla función de predict de  un modelo a `sql`  y la segunda traduce todo el `workflow`\n\n\n## Hagamos la prueba\n\nVamos a usar el ejemplo que tienen en la docu con `mtcars`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(vip)\nlibrary(bigrquery)\nlibrary(DBI)\nlibrary(dbplyr)\n# remotes::install_github(\"tidymodels/orbital\")\nlibrary(orbital)\n```\n:::\n\n\n\nComo BD voy a usar `bigquery`, utilizo \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tengo variables de entorno con mi mail y el proyecto de bq personal\nbq_auth(email = Sys.getenv(\"MIGMAIL\")) \nmi_proyecto <- Sys.getenv(\"BQ_PROJECT_JLCR\")\nsc <- src_bigquery(mi_proyecto, dataset = NULL,  max_pages = 10)\n```\n:::\n\n\n\nComprobamos que ha ido bien y que puedo ver una tabla que tengo ahí de prueba\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabla1  <-  sc  %>% tbl(I(\"churn2.tabla_churn\"))\ntabla1  %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # Source:   SQL [6 x 21]\n#> # Database: BigQueryConnection\n#>   customerID gender SeniorCitizen Partner Dependents tenure PhoneService\n#>   <chr>      <chr>          <int> <lgl>   <lgl>       <int> <lgl>       \n#> 1 9732-OUYRN Female             0 TRUE    FALSE          49 TRUE        \n#> 2 0661-KQHNK Female             0 TRUE    TRUE            6 TRUE        \n#> 3 4709-LKHYG Female             0 TRUE    TRUE           29 TRUE        \n#> 4 9824-QCJPK Male               0 TRUE    FALSE          36 TRUE        \n#> 5 4716-MRVEN Female             0 FALSE   FALSE          29 TRUE        \n#> 6 8084-OIVBS Female             0 FALSE   FALSE          11 TRUE        \n#> # ℹ 14 more variables: MultipleLines <chr>, InternetService <chr>,\n#> #   OnlineSecurity <chr>, OnlineBackup <chr>, DeviceProtection <chr>,\n#> #   TechSupport <chr>, StreamingTV <chr>, StreamingMovies <chr>,\n#> #   Contract <chr>, PaperlessBilling <lgl>, PaymentMethod <chr>,\n#> #   MonthlyCharges <dbl>, TotalCharges <chr>, Churn <lgl>\n```\n\n\n:::\n:::\n\n\n\nAhora subo una parte de mtcars a bigquery\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <- mtcars[25:32, ]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# creamos la tabla en bigquery en miproyecto.dataset.tbname\n\n# # borro si ya existia \n# mtcars_test_db_prev <- bq_table(mi_proyecto, \"churn2\", \"test\")\n# bq_table_delete(mtcars_test_db_prev)\n\n# creo la tabla de nuevo\nmtcars_test_db <- bq_table(mi_proyecto, \"churn2\", \"test\")\n\n# subo datos a esa tabla\nbq_table_upload(mtcars_test_db, test)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# compruebo qeue se ha subido\nmtcars_bq  <- sc  |> tbl(I(\"churn2.test\"))\n\nmtcars_bq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # Source:   table<churn2.test> [8 x 11]\n#> # Database: BigQueryConnection\n#>      am  carb    vs  qsec    wt  drat  disp    hp   cyl  gear   mpg\n#>   <int> <int> <int> <dbl> <dbl> <dbl> <dbl> <int> <int> <int> <dbl>\n#> 1     0     2     0  17.0  3.84  3.08 400     175     8     3  19.2\n#> 2     1     2     0  16.7  2.14  4.43 120.     91     4     5  26  \n#> 3     1     4     0  14.5  3.17  4.22 351     264     8     5  15.8\n#> 4     1     6     0  15.5  2.77  3.62 145     175     6     5  19.7\n#> 5     1     8     0  14.6  3.57  3.54 301     335     8     5  15  \n#> 6     1     1     1  18.9  1.94  4.08  79      66     4     4  27.3\n#> 7     1     2     1  16.9  1.51  3.77  95.1   113     4     5  30.4\n#> 8     1     2     1  18.6  2.78  4.11 121     109     4     4  21.4\n```\n\n\n:::\n:::\n\n\n\n## Entrenamos un modelo con tidymodels\n\nEntreno un modelo simple con tidymodels, el entrenamiento se hace sobre data.frame normal de R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain <- mtcars[1:24,]\n\n# preproceso\nrec_spec <- recipe(mpg ~ ., data = train) |> \n  step_normalize(all_numeric_predictors())\n\n# instancio un modelo linear simple\n\nlm_spec <- linear_reg(mode = \"regression\", engine = \"lm\")\n# flujo que uno prepdocesamiento y modelo\nwf_linear <- workflow() |> \n  add_recipe(rec_spec)  |> \n  add_model(lm_spec)\n\n\n\n\n# Ajusto el workflow sobre datos de train\nwf_fit <- fit(wf_linear, train)\n\nwf_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> ══ Workflow [trained] ══════════════════════════════════════════════════════════\n#> Preprocessor: Recipe\n#> Model: linear_reg()\n#> \n#> ── Preprocessor ────────────────────────────────────────────────────────────────\n#> 1 Recipe Step\n#> \n#> • step_normalize()\n#> \n#> ── Model ───────────────────────────────────────────────────────────────────────\n#> \n#> Call:\n#> stats::lm(formula = ..y ~ ., data = data)\n#> \n#> Coefficients:\n#> (Intercept)          cyl         disp           hp         drat           wt  \n#>    19.50417      1.70021     -0.50385     -0.39324      2.68970     -0.39831  \n#>        qsec           vs           am         gear         carb  \n#>     0.98482      0.06173      1.43663      0.86633     -2.76451\n```\n\n\n:::\n\n```{.r .cell-code}\nwf_fit %>% \n  extract_fit_parsnip() %>% \n  vip(num_features = 3)\n```\n\n::: {.cell-output-display}\n![](orbital_entornos_hostiles_files/figure-html/unnamed-chunk-7-1.png){width=80%}\n:::\n:::\n\n\n\nvemos predicciones sobre test \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediciones <-  predict(wf_fit, test)\ntest_with_pred <-  test |> \n    mutate(\n        pred = prediciones$.pred\n    )\ntest_with_pred |> \n    select(mpg, pred, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                   mpg     pred cyl  disp  hp drat    wt  qsec vs am gear carb\n#> Pontiac Firebird 19.2 17.02483   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n#> Fiat X1-9        27.3 29.26171   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#> Porsche 914-2    26.0 28.64553   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n#> Lotus Europa     30.4 25.83187   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#> Ford Pantera L   15.8 23.27644   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n#> Ferrari Dino     19.7 16.08932   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n#> Maserati Bora    15.0 10.66091   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n#> Volvo 142E       21.4 26.21461   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n```\n\n\n:::\n:::\n\n\n\n## Uso de orbital\n\nCon orbital podemos utilizar el  `workflow` de tidymodels y que el preprocesamiento y la predicción se haga en la base de datos, gracias al uso de la librería `tidypredict`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nota. no se puede usar ccomo nombre de columna en bigquery algo\n# que empiece por \".\" Les puse un issue  alos de orbital y lo arreglaron, \n# pero el fix es en la versión latest, instalr con \n#  remotes::install_github(\"tidymodels/orbital\")\n\norbital_lm_wf  <- orbital(wf_fit, prefix = \"prediction\")\n\n# lo aplicamos a la tabla en bigquery\n\npredict(orbital_lm_wf, mtcars_bq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # Source:   SQL [8 x 1]\n#> # Database: BigQueryConnection\n#>   prediction\n#>        <dbl>\n#> 1       17.0\n#> 2       28.6\n#> 3       23.3\n#> 4       16.1\n#> 5       10.7\n#> 6       29.3\n#> 7       25.8\n#> 8       26.2\n```\n\n\n:::\n:::\n\n\nPodemos ver el código `sql` por si queremos utilizarlo en un entorno hostil dónde sólo podamos ejecutar cosas con sql\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Este sería el código en dplyr que se manda a bigquery \npred_query  <- mtcars_bq  |> \n    mutate(!!!orbital_inline(orbital_lm_wf)) |> \n    select(mpg, prediction, everything())\n\n# vemos el código sql \nsql_render(pred_query)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> <SQL> SELECT\n#>   `mpg`,\n#>   (((((((((19.5041666666667 + (`cyl` * 1.70020928104393)) + (`disp` * -0.503852370218672)) + (`hp` * -0.39323963869249)) + (`drat` * 2.68969716287516)) + (`wt` * -0.398305964689505)) + (`qsec` * 0.984815350290373)) + (`vs` * 0.0617323594407886)) + (`am` * 1.43662793743514)) + (`gear` * 0.86633019389466)) + (`carb` * -2.76451303896608) AS `prediction`,\n#>   `am`,\n#>   `carb`,\n#>   `vs`,\n#>   `qsec`,\n#>   `wt`,\n#>   `drat`,\n#>   `disp`,\n#>   `hp`,\n#>   `cyl`,\n#>   `gear`\n#> FROM (\n#>   SELECT\n#>     (`am` - 0.25) / 0.442325868464691 AS `am`,\n#>     (`carb` - 2.625) / 1.24455335099716 AS `carb`,\n#>     (`vs` - 0.458333333333333) / 0.508977377704051 AS `vs`,\n#>     (`qsec` - 18.2670833333333) / 1.65471258286267 AS `qsec`,\n#>     (`wt` - 3.38454166666667) / 0.986562234056558 AS `wt`,\n#>     (`drat` - 3.51) / 0.543787042716252 AS `drat`,\n#>     (`disp` - 240.445833333333) / 123.862055035173 AS `disp`,\n#>     (`hp` - 140.25) / 59.6141579332205 AS `hp`,\n#>     (`cyl` - 6.33333333333333) / 1.73622946456486 AS `cyl`,\n#>     (`gear` - 3.41666666666667) / 0.503610155185335 AS `gear`,\n#>     `mpg`\n#>   FROM churn2.test\n#> ) `q01`\n```\n\n\n:::\n:::\n\n\n\n\nPodemos escribir la query en un fichero \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite(sql_render(pred_query), \"mpg_lm.sql\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(readLines(\"mpg_lm.sql\"), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> SELECT\n#>   `mpg`,\n#>   (((((((((19.5041666666667 + (`cyl` * 1.70020928104393)) + (`disp` * -0.503852370218672)) + (`hp` * -0.39323963869249)) + (`drat` * 2.68969716287516)) + (`wt` * -0.398305964689505)) + (`qsec` * 0.984815350290373)) + (`vs` * 0.0617323594407886)) + (`am` * 1.43662793743514)) + (`gear` * 0.86633019389466)) + (`carb` * -2.76451303896608) AS `prediction`,\n#>   `am`,\n#>   `carb`,\n#>   `vs`,\n#>   `qsec`,\n#>   `wt`,\n#>   `drat`,\n#>   `disp`,\n#>   `hp`,\n#>   `cyl`,\n#>   `gear`\n#> FROM (\n#>   SELECT\n#>     (`am` - 0.25) / 0.442325868464691 AS `am`,\n#>     (`carb` - 2.625) / 1.24455335099716 AS `carb`,\n#>     (`vs` - 0.458333333333333) / 0.508977377704051 AS `vs`,\n#>     (`qsec` - 18.2670833333333) / 1.65471258286267 AS `qsec`,\n#>     (`wt` - 3.38454166666667) / 0.986562234056558 AS `wt`,\n#>     (`drat` - 3.51) / 0.543787042716252 AS `drat`,\n#>     (`disp` - 240.445833333333) / 123.862055035173 AS `disp`,\n#>     (`hp` - 140.25) / 59.6141579332205 AS `hp`,\n#>     (`cyl` - 6.33333333333333) / 1.73622946456486 AS `cyl`,\n#>     (`gear` - 3.41666666666667) / 0.503610155185335 AS `gear`,\n#>     `mpg`\n#>   FROM churn2.test\n#> ) `q01`\n```\n\n\n:::\n:::\n\n\n\n\n## Un modelo un poco más complejo\n\nLo típico es que se usen modelo algo más complejos. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_spec <- recipe(mpg ~ ., data = train) %>%\n  step_normalize(all_numeric_predictors())\n\nxgb_spec <- boost_tree(\n  trees = 10,\n  tree_depth = 3, min_n = 2,\n) %>%\n  set_engine(\"xgboost\") %>%\n  set_mode(\"regression\")\n\n\n\n\nxgb_wf <- workflow() %>%\n  add_recipe(rec_spec)  |> \n  add_model(xgb_spec)\n\n\n\nxgb_fit <- fit(xgb_wf, mtcars)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\norbital_xgb  <- orbital(xgb_fit, prefix = \"prediction\")\n```\n:::\n\n\n\npodemos predecir en la bd usando `predict(orbital_object, tabla_remota` o también usar sintaxis de dplyr y ver el código `sql` generado.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Este sería el código en dplyr que se manda a bigquery \npred_query_xgb  <- mtcars_bq  |> \n    mutate(!!!orbital_inline(orbital_xgb)) |> \n    select(mpg, prediction, everything()) |> \n    arrange(mpg)\n\npred_query_xgb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # Source:     SQL [8 x 12]\n#> # Database:   BigQueryConnection\n#> # Ordered by: mpg\n#>     mpg prediction    am  carb    vs   qsec      wt    drat   disp     hp    cyl\n#>   <dbl>      <dbl> <int> <int> <int>  <dbl>   <dbl>   <dbl>  <dbl>  <dbl>  <dbl>\n#> 1  15         14.2     1     8     0 -1.82   0.361  -0.106   0.567  2.75   1.01 \n#> 2  15.8       15.1     1     4     0 -1.87  -0.0483  1.17    0.970  1.71   1.01 \n#> 3  19.2       16.5     0     2     0 -0.447  0.642  -0.966   1.37   0.413  1.01 \n#> 4  19.7       19.8     1     6     0 -1.31  -0.457   0.0438 -0.692  0.413 -0.105\n#> 5  21.4       21.4     1     2     1  0.420 -0.447   0.960  -0.885 -0.550 -1.22 \n#> 6  26         25.0     1     2     0 -0.643 -1.10    1.56   -0.891 -0.812 -1.22 \n#> 7  27.3       27.5     1     1     1  0.588 -1.31    0.904  -1.22  -1.18  -1.22 \n#> 8  30.4       28.1     1     2     1 -0.531 -1.74    0.324  -1.09  -0.491 -1.22 \n#> # ℹ 1 more variable: gear <int>\n```\n\n\n:::\n:::\n\n\n\n\nY vemos que concuerda con la predicción en en local\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npred_xgb_local <-  predict(xgb_fit, test)\ntest |> \n    mutate(pred_xgb = pred_xgb_local$.pred) |> \n    arrange(mpg) |> \n    select(mpg, pred_xgb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                   mpg pred_xgb\n#> Maserati Bora    15.0 14.22048\n#> Ford Pantera L   15.8 15.09601\n#> Pontiac Firebird 19.2 16.46817\n#> Ferrari Dino     19.7 19.79652\n#> Volvo 142E       21.4 21.38598\n#> Porsche 914-2    26.0 25.04269\n#> Fiat X1-9        27.3 27.46302\n#> Lotus Europa     30.4 28.06620\n```\n\n\n:::\n:::\n\n\n\n\nPodemos escribir la query en un fichero, que sería la query que iría a producción\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite(sql_render(pred_query_xgb), \"mpg_xgb.sql\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(readLines(\"mpg_xgb.sql\"), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> SELECT\n#>   `mpg`,\n#>   ((((((((((0.0 + CASE\n#> WHEN ((`cyl` < 0.454947203 OR (`cyl` IS NULL))) THEN 6.67105246\n#> WHEN (`cyl` >= 0.454947203) THEN 4.0880003\n#> END) + CASE\n#> WHEN ((`cyl` < -0.664922833 OR (`cyl` IS NULL))) THEN 5.36046076\n#> WHEN ((`disp` < 1.7692467 OR (`disp` IS NULL)) AND `cyl` >= -0.664922833) THEN 3.35319948\n#> WHEN (`disp` >= 1.7692467 AND `cyl` >= -0.664922833) THEN 1.16239989\n#> END) + CASE\n#> WHEN ((`wt` < -0.978325605 OR (`wt` IS NULL))) THEN 4.5090394\n#> WHEN ((`disp` < 1.7692467 OR (`disp` IS NULL)) AND `wt` >= -0.978325605) THEN 2.52093935\n#> WHEN (`disp` >= 1.7692467 AND `wt` >= -0.978325605) THEN 0.929919958\n#> END) + CASE\n#> WHEN ((`wt` < -0.978325605 OR (`wt` IS NULL))) THEN 3.34957242\n#> WHEN ((`hp` < 0.668182373 OR (`hp` IS NULL)) AND `wt` >= -0.978325605) THEN 1.93179655\n#> WHEN (`hp` >= 0.668182373 AND `wt` >= -0.978325605) THEN 1.05857491\n#> END) + CASE\n#> WHEN ((`disp` < -1.04222393 OR (`disp` IS NULL))) THEN 2.62246895\n#> WHEN ((`hp` < 0.668182373 OR (`hp` IS NULL)) AND `disp` >= -1.04222393) THEN 1.39560235\n#> WHEN (`hp` >= 0.668182373 AND `disp` >= -1.04222393) THEN 0.780699074\n#> END) + CASE\n#> WHEN (`wt` >= 0.110122316) THEN 0.68489337\n#> WHEN ((`disp` < -1.04222393 OR (`disp` IS NULL)) AND (`wt` < 0.110122316 OR (`wt` IS NULL))) THEN 1.96685159\n#> WHEN (`disp` >= -1.04222393 AND (`wt` < 0.110122316 OR (`wt` IS NULL))) THEN 1.15808082\n#> END) + CASE\n#> WHEN ((`disp` < -1.04222393 OR (`disp` IS NULL))) THEN 1.47513843\n#> WHEN ((`wt` < 0.110122316 OR (`wt` IS NULL)) AND `disp` >= -1.04222393) THEN 0.83960855\n#> WHEN ((`qsec` < -0.0776465684 OR (`qsec` IS NULL)) AND `wt` >= 0.110122316 AND `disp` >= -1.04222393) THEN 0.567495942\n#> WHEN (`qsec` >= -0.0776465684 AND `wt` >= 0.110122316 AND `disp` >= -1.04222393) THEN 0.301891834\n#> END) + CASE\n#> WHEN ((`disp` < -1.22537899 OR (`disp` IS NULL))) THEN 1.30021882\n#> WHEN ((`drat` < -1.26536262 OR (`drat` IS NULL)) AND (`hp` < 0.449405074 OR (`hp` IS NULL)) AND `disp` >= -1.22537899) THEN 0.119869716\n#> WHEN (`drat` >= -1.26536262 AND (`hp` < 0.449405074 OR (`hp` IS NULL)) AND `disp` >= -1.22537899) THEN 0.631567359\n#> WHEN ((`wt` < 0.549589574 OR (`wt` IS NULL)) AND `hp` >= 0.449405074 AND `disp` >= -1.22537899) THEN 0.35708189\n#> WHEN (`wt` >= 0.549589574 AND `hp` >= 0.449405074 AND `disp` >= -1.22537899) THEN 0.191202134\n#> END) + CASE\n#> WHEN ((`disp` < -1.22537899 OR (`disp` IS NULL))) THEN 1.00766969\n#> WHEN ((`qsec` < -0.377040505 OR (`qsec` IS NULL)) AND (`hp` < 0.668182373 OR (`hp` IS NULL)) AND `disp` >= -1.22537899) THEN 0.549484432\n#> WHEN (`qsec` >= -0.377040505 AND (`hp` < 0.668182373 OR (`hp` IS NULL)) AND `disp` >= -1.22537899) THEN 0.298643202\n#> WHEN ((`disp` < 0.966430426 OR (`disp` IS NULL)) AND `hp` >= 0.668182373 AND `disp` >= -1.22537899) THEN 0.0644110739\n#> WHEN (`disp` >= 0.966430426 AND `hp` >= 0.668182373 AND `disp` >= -1.22537899) THEN 0.194638208\n#> END) + CASE\n#> WHEN ((`disp` < -1.22537899 OR (`disp` IS NULL))) THEN 0.78094399\n#> WHEN ((`drat` < 0.754541874 OR (`drat` IS NULL)) AND (`hp` < -0.418411613 OR (`hp` IS NULL)) AND `disp` >= -1.22537899) THEN 0.430569261\n#> WHEN (`drat` >= 0.754541874 AND (`hp` < -0.418411613 OR (`hp` IS NULL)) AND `disp` >= -1.22537899) THEN 0.0782236606\n#> WHEN ((`hp` < 0.230627745 OR (`hp` IS NULL)) AND `hp` >= -0.418411613 AND `disp` >= -1.22537899) THEN (-0.0337554961)\n#> WHEN (`hp` >= 0.230627745 AND `hp` >= -0.418411613 AND `disp` >= -1.22537899) THEN 0.245185137\n#> END) + 0.5 AS `prediction`,\n#>   `am`,\n#>   `carb`,\n#>   `vs`,\n#>   `qsec`,\n#>   `wt`,\n#>   `drat`,\n#>   `disp`,\n#>   `hp`,\n#>   `cyl`,\n#>   `gear`\n#> FROM (\n#>   SELECT\n#>     `am`,\n#>     `carb`,\n#>     `vs`,\n#>     (`qsec` - 17.84875) / 1.78694323609684 AS `qsec`,\n#>     (`wt` - 3.21725) / 0.978457442989697 AS `wt`,\n#>     (`drat` - 3.5965625) / 0.534678736070971 AS `drat`,\n#>     (`disp` - 230.721875) / 123.938693831382 AS `disp`,\n#>     (`hp` - 146.6875) / 68.5628684893206 AS `hp`,\n#>     (`cyl` - 6.1875) / 1.78592164694654 AS `cyl`,\n#>     `gear`,\n#>     `mpg`\n#>   FROM churn2.test\n#> ) `q01`\n#> ORDER BY `mpg`\n```\n\n\n:::\n:::\n\n\n\n## Conclusión\n\nLa librería orbital permite pasar un preprocesamiento y  modelos complejos de tidymodels a sentencias sql que se pueden usar en entornos hostiles y productivizar sin necesidad de tener instalado R, ni docker, ni nada. \nEvidentemente esto va a generar unas queries que pueden llegar a ser infernales, pero cuando no tienes otra opción \nesta puede ser tan buena como otra. \n\n\n\n",
    "supporting": [
      "orbital_entornos_hostiles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}