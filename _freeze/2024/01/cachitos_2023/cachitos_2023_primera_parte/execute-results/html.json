{
  "hash": "20ebd0f05bac638cafffc679ade8ce0d",
  "result": {
    "markdown": "---\ntitle: Cachitos 2023. Primera parte\ndate: '2024-01-02'\ncategories: \n  - estadística\n  - polémica\n  - 2024\n  - textmining\n  - ocr\n  - linux\n  - cachitos\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 9\n    fig-align: center\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\nimage: \"00000035.jpg\"\n---\n\n\n\nComo todos los años toca hacer el análisis de de los subtítulos de _Nochevieja a Cachitos_\n\nEste año resulta que la gente de RTVE ha capado el poder bajarse los videos desde rtve usando `curl` o `wget` , pero gracias a [Javi Fdez](https://twitter.com/jfcrz) he podido bajarme el video tirando de la url del streaming . \n\n\n## Requisitos\n\n* Un plugin en el navegador que pueda identificar el `m3u` asociado al archivo `mp4` del video de Cachitos que está en rtve play. Yo he usado [live Stream Downloader](https://chromewebstore.google.com/detail/live-stream-downloader/looepbdllpjgdmkpdcdffhdbmpbcfekj) , pero seguro que hay alguno mejor\n* Usar un sistema operativo GNU/Linux, en mi caso Linux Mint 21.2 basada en Ubuntu Jammy\n* `ffmpeg`  `sudo apt install ffmpeg` . ffmpeg nos va a servir para poder bajar el video \n* `mplayer` `sudo apt install mplayer`. `mplayer` con `mplayer` vamos a extraer 1 de cada 200 fotogramas del video\n*  `imagemagick` con `sudo apt install imagemagick`. Con `imagemagick` vamos a cambiar el tamaño de los fotogramas, recortar el área dónde están los subtítulos, convertir a formato `tif` e invertir los colores para que el texto se vea mejor. \n* `parallel` `sudo apt install parallel` . Con `parallel` vamos a poder utilizar varios núcleos e hilos del ordenador en paralelo y poder hacer la modificación de los fotogramas y el reconocimiento óptico de caracteres más rápido. \n* `tesseract` `sudo apt install tesseract-ocr` y `sudo apt install tesseract-ocr-spa` . Con `tesseract` se va a hacer el reconocimiento óptico del texto y guardar en ficheros de texto. \n* Elimina ficheros de texto de menos de 10 bytes, puesto que ahí no hay texto . \n\n\n## Plugin \n\nCon el plugin de Live Stream instalado en el navegador, lo primero que hacemos es ir a la web de rtveplay, buscar Nochevieja a Cachitos y darle al play. \nEstando en esa pestaña, le damos al plugin y nos abrirá una ventana emergente dónde se nos ha copiado la info del streaming. Esta info será útil porque es lo que nos va a permitir poder bajar el video usando `ffmpeg`\n\n![plugin](plugin.png)\n\nLa info que nos da es algo como esto\n\n`https://rtvehlsvodlote7.rtve.es/mediavodv2/resources/TE_SHIECRO/mp4/3/1/1704096565613.mp4/1704096565613-audio=192755-video=2752986-3331.ts?idasset=7047821`\n\nEn años anteriores me podía bajar directamente el archivo mp4 usando wget, pero este año nuestros amigos de rtve han decidido que no se puede. \n\nEsto es lo que  me sale al intentarlo\n\n```\n wget https://rtvehlsvodlote7.rtve.es/mediavodv2/resources/TE_SHIECRO/mp4/3/1/1704096565613.mp4\n--2024-01-02 13:15:27--  https://rtvehlsvodlote7.rtve.es/mediavodv2/resources/TE_SHIECRO/mp4/3/1/1704096565613.mp4\nResolviendo rtvehlsvodlote7.rtve.es (rtvehlsvodlote7.rtve.es)... 151.101.134.137, 2a04:4e42:1f::649\nConectando con rtvehlsvodlote7.rtve.es (rtvehlsvodlote7.rtve.es)[151.101.134.137]:443... conectado.\nPetición HTTP enviada, esperando respuesta... 403 Forbidden\n2024-01-02 13:15:27 ERROR 403: Forbidden.\n```\n\nVolviendo a la info que hemos obtenido usando el plugin, es importante identificar el idasset, en este caso el 7047821. \nUna vez sabemos eso, justo después de la parte dónde viene indicado el mp4, la cambiamos por esto \n\n`video.m3u8?hls_no_audio_only=true&hls_client_manifest_version=3&idasset=7047821` y ya podemos usar `ffmpeg` para guardar el archivo. \n\nSon casi unos 4gb de video.\n\n`ffmpeg -i \"https://rtvehlsvodlote7.rtve.es/mediavodv2/resources/TE_SHIECRO/mp4/3/1/1704096565613.mp4/video.m3u8?hls_no_audio_only=true&hls_client_manifest_version=3&idasset=7047821\" -c copy video.mp4`\n\n## Script de bash\n\nEl script es [`extract_subtitles.sh`](../extract_subtitles.sh)\n, se ejecutaría con `extract_subtitles.sh 2023` . \n\nVamos a ir comentando el script poco a poco \n\n### Bajar video\n\nIndicamos el nombre del directorio donde queremos trabajar, lo creamos y también creamos un subdirectorio llamado `video` , nos situamos en él y creamos algunas variables como el nombre del video cuando nos lo bajemos o como se van a llamar los directorios dónde vamos a ir guardando los fotogramas o el texto, típicamente `2023_jpg` y `2023_txt`. El script está puesto para que se le pase el año y se construya el \n\n```bash\nroot_directory=/home/jose/proyecto_cachitos\nmkdir -p $root_directory\ncd $root_directory\n\necho \"First arg: $1\"\nmkdir -p video\n\ncd video\n\nANNO=$1\necho $ANNO\nsuffix_video=\"_cachitos.mp4\"\nsuffix_jpg_dir=\"_jpg\"\nsuffix_txt_dir=\"_txt\"\n\nvideo_file=$ANNO$suffix_video\necho $video_file\n\n\nif [ \"$ANNO\" == \"2023\" ] ;\nthen\n    ffmpeg -i \"https://rtvehlsvodlote7.rtve.es/mediavodv2/resources/TE_SHIECRO/mp4/3/1/1704096565613.mp4/video.m3u8?hls_no_audio_only=true&hls_client_manifest_version=3&idasset=7047821\" -c copy $video_file\nfi\n```\n\n\n### Extracción de fotogramas\n\nUsando mplayer que sirve para reproducir el vídeo, podemos indicar además  que nos extraiga una imagen cada 200 fotogramas `framestep=200`, también le decimos que lo reproduzca sin sonido y a velocidad alta y que guarde esos fotogramas como archivos jpeg en la ruta relativa `2023_jpg dentro de nuestro directorio principal. \n\nEste es el comando que hace todo eso\n\n```bash\nmplayer -vf framestep=200 -framedrop -nosound $video_file -speed 100 -vo jpeg:outdir=$ANNO$suffix_jpg_dir \n\n```\n\n\n### Recorte de la zona de dónde está el rótulo\n\nDe años anteriores sé que si \"achico\" cada imagen anterior me vale de igual forma y por prueba y error vi en que parte de la imagen suelen colocar los rótulos. Así que con herramientas de `imagemagick` puedo manipular esas imágenes y extraer solo la zona del rótulo. \n\n#### Reducción de la imagen\n\nCambiamos al directorio dónde hemos dejado las imágenes, y usando el comando `find` seleccionamos todos los archivos con extensión `jpg` y los reducimos a formato de 642x480. \n\nPara eso usamos `mogrify` que forma parte de `imagemagick` y la parte de usar `parallel` es para que se ejecute en paralelo usando 8 hilos de cpu. \n\n```bash\n \ncd $ANNO$suffix_jpg_dir \n \n# Convertir a formato más pequño\nfind . -name '*.jpg' |  parallel -j 8 mogrify -resize 642x480 {}\n```\n\n#### Seleccionar la zona dónde están los rótulos\n\n\nAhora usamos otras funciones de `imagemagick` que son `convert` y `crop` . Lo que hacemos es convertir a formato tif y recortamos justo la zona dónde están los rótulos.  \nAsí, para cada imagen jpg creamos un archivo con nombre `nombre_imagen.jpg.subtitulo.tif` \n\n\n```bash \n\n# Seleccionar cacho dond están subtitulos\nfind . -name '*.jpg' |  parallel -j 8 convert {} -crop 460x50+90+285 +repage -compress none -depth 8 {}.subtitulo.tif\n\n```\n\n\n#### Hacer el negativo de las imágenes \n\nPara ayudar al software de reconocimiento óptico de caractereres obtenemos el negativo de cada tif. Para eso usamos de nuevo convert pero con la opción `negate`\n\n\n```bash\n\n# Poner en negativo para que el ocr funcione mejor\nfind . -name '*.tif' |  parallel -j 8 convert {} -negate -fx '.8*r+.8*g+0*b' -compress none -depth 8 {}\n\n```\n\n![subtitulo_negativo](00000035.jpg.subtitulo.jpg)\n\n### Reconocimiento óptico de caracteres\n\nNosotros lo que queremos es tener el texto, no una imagen. Para eso utilizamos [`tesseract`](https://es.wikipedia.org/wiki/Tesseract_OCR). Le pasamos cada una de las imágenes anteriores en formato tif y nos devolverá el texto que contienen. No siempre lo hará bien, pero el resultado es aceptable. También creamos directorio dónde vamos a mover todos los ficheros de texto creados y eliminamos los ficheros con menos de 10 bytes. \n\n```bash\n# Pasar el ocr con idioma en español\nfind . -name '*.tif' |  parallel -j 8 tesseract -l spa {} {}\n\n# mover a directorio texto\nmkdir -p $root_directory/$ANNO$suffix_txt_dir\n\nmv *.txt $root_directory/$ANNO$suffix_txt_dir\n\ncd $root_directory/$ANNO$suffix_txt_dir\n\n# Borrar archivos de 10 bytes , subtítulos vacíos, bytes se indican con la letra c, cosas de linux\nfind . -size -10c -exec rm -f {} \\;\n\n```\n\nY podemos ver cómo ha convertido por ejemplo el rótulo asociado al fotograma 35. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncmd <-  \"cat ~/proyecto_cachitos/2023_txt/00000035.jpg.subtitulo.tif.txt\"\nsystem(cmd, intern = TRUE)\n#> [1] \"ste tema se escribió con cartas de mujeres con cáncer de mama\"    \n#> [2] \"\"                                                                 \n#> [3] \"Si te ha tocado este año, lo de la amnistía igual lo relativizas.\"\n#> [4] \"\\f\"\n```\n:::\n\n\nComo vemos, la lógica de la creación de los ficheros de texto ha sido la de ir guardando el nombre original del fotograma e ir añadiendo extensiones, (.jpg, .subtitulo.tif, .txt). \n\n\n\nY sin más, os dejo también aquí el script entero\n\n\n```bash\n#!/bin/bash\n\nroot_directory=/home/jose/proyecto_cachitos\nmkdir -p $root_directory\ncd $root_directory\n\necho \"First arg: $1\"\nmkdir -p video\n\ncd video\n\nANNO=$1\necho $ANNO\nsuffix_video=\"_cachitos.mp4\"\nsuffix_jpg_dir=\"_jpg\"\nsuffix_txt_dir=\"_txt\"\n\nvideo_file=$ANNO$suffix_video\necho $video_file\n\n\nif [ \"$ANNO\" == \"2023\" ] ;\nthen\n    ffmpeg -i \"https://rtvehlsvodlote7.rtve.es/mediavodv2/resources/TE_SHIECRO/mp4/3/1/1704096565613.mp4/video.m3u8?hls_no_audio_only=true&hls_client_manifest_version=3&idasset=7047821\" -c copy $video_file\nfi\n\nif [ \"$ANNO\" == \"2022\" ] ;\nthen\n    ffmpeg -i \"https://rtvehlsvodlote7.rtve.es/mediavodv2/resources/TE_SHIECRO/mp4/1/5/1672556504451.mp4/video.m3u8?hls_no_audio_only=true&hls_client_manifest_version=3&idasset=6767615\" -c copy $video_file\nfi \n \n\n# Pasar a jpg uno de cada 200 fotogramas\n\nmplayer -vf framestep=200 -framedrop -nosound $video_file -speed 100 -vo jpeg:outdir=$ANNO$suffix_jpg_dir \n \ncd $ANNO$suffix_jpg_dir \n \n# Convertir a formato más pequño\nfind . -name '*.jpg' |  parallel -j 8 mogrify -resize 642x480 {}\n\n# Seleccionar cacho dond están subtitulos\nfind . -name '*.jpg' |  parallel -j 8 convert {} -crop 460x50+90+285 +repage -compress none -depth 8 {}.subtitulo.tif\n\n# Poner en negativo para que el ocr funcione mejor\nfind . -name '*.tif' |  parallel -j 8 convert {} -negate -fx '.8*r+.8*g+0*b' -compress none -depth 8 {}\n\n# Pasar el ocr con idioma en español\nfind . -name '*.tif' |  parallel -j 8 tesseract -l spa {} {}\n\n# mover a directorio texto\nmkdir -p $root_directory/$ANNO$suffix_txt_dir\n\nmv *.txt $root_directory/$ANNO$suffix_txt_dir\n\ncd $root_directory/$ANNO$suffix_txt_dir\n\n# Borrar archivos de 10 bytes , subtítulos vacíos\nfind . -size -10c -exec rm -f {} \\;\n\ncd $root_directory\n\n```\n\n\n## Algún ejemplo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nroot_directory = \"~/proyecto_cachitos/\"\nanno <- \"2023\"\nlibrary(magick)\n(directorio_imagenes <- str_glue(\"{root_directory}video/{anno}_jpg/\"))\n#> ~/proyecto_cachitos/video/2023_jpg/\n\nimage_read(str_glue(\"{directorio_imagenes}00001297.jpg\"))\n```\n\n::: {.cell-output-display}\n![](cachitos_2023_primera_parte_files/figure-html/unnamed-chunk-2-1.png){width=80%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nimage_read(str_glue(\"{directorio_imagenes}00001297.jpg.subtitulo.tif\"))\n```\n\n::: {.cell-output-display}\n![](cachitos_2023_primera_parte_files/figure-html/unnamed-chunk-3-1.png){width=80%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\n(directorio_texto <- str_glue(\"{root_directory}{anno}_txt/\"))\n#> ~/proyecto_cachitos/2023_txt/\n\nsystem(str_glue(\"cat {directorio_texto}00001297.jpg.subtitulo.tif.txt\"), intern = TRUE)\n#> [1] \"Con el tiempo descubrimos que todas las letras de este\"\n#> [2] \"exprofesor de Primaria tenian referencias sexuales.\"   \n#> [3] \"\\f\"\n```\n:::\n\n\nY poco más, mañana intentaré tener el[post similar al del año pasado](../../../2023/01/03/cachitos-2022-segunda-parte/index.qmd) dónde veíamos distancias de texto entre rótulos y demás. \n",
    "supporting": [
      "cachitos_2023_primera_parte_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}