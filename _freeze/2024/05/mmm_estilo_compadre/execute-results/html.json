{
  "hash": "9dedebbf82dbab33395980015119ab62",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"MMM. Estilo compadre\"  \ndate: '2024-05-??'\ncategories: \n  - 2024\n  - Marketing \n  - análisis bayesiano\n  - R\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8\n    fig-align: center\n    code-fold: show\n    code-summary: \"Show the code\"\nimage: curva_saturacion.png\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n---\n\n\n::: callout-note\n## Listening\n\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/track/4bO6DljpuAeQh6HS20i0I5?utm_source=generator\" width=\"100%\" height=\"250\" frameBorder=\"0\" allowfullscreen allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\">\n\n</iframe>\n\n\n:::\n\n\n\n## Confesión\n\nHe de reconocer que mi conocimiento sobre lo que se ha dado en llamar el Marketing/Media Mix Modelling\nes más bien escaso por no decir que inexistente. No obstante, una reunión el otro día en el trabajo \nhizo despertar mi  curiosidad. Así que voy a contar un poco lo que he aprendido. \n\n\n## Qué es esto del marketing  mix modelling. \n\nPues en teoría es un intento de inferencia causal, que intenta responder a la pregunta de ¿qué pasa \ncon las ventas si aumento mi inversión publicitaria en un canal _a_ ? ¿ Y si cambio por completo el \nmix de gasto en publicidad?  ¿Si tengo un presupuesto _Z_, cuál es la forma óptima de asignar gasto a cada medio? \n\n\nBien, pues para poder contestar a estas preguntas lo primero de todo es asumir que las ventas están \nrelacionadas e incluso son causa de la inversión en publicidad. Suena a palabras mayores, desde luego,\npero que le vamos a hacer, esto es lo que hay. \n\nUno podría (y debería) pintar un DAG que expresase lo que creemos saber sobre la relación entre las \nvariables. Quizá el gasto en _radio_ influya en que el gasto en _google_ sea más eficaz, y cosas así. \nPero como yo estoy empezando a aprender sobre este tema, voy a partir del supuesto, de que una regresión\nmúltiple me permite expresar las relaciones _causales_ entre las variables, y además que se dan todo \nel resto de supuestos para la _inferencia causal_ y por tanto, podría interpretar los coeficientes como \nefectos causales. Si, ya lo sé, esto es un triple salto mortal, pero es lo que se hace todos los días \nen las empresas. Ya habrá tiempo de cuestionar estas cosas. \n\n\n\n## Unos datillos de ejemplo\n\nEn la librería `datarium` tenemos unos datos de marketing que nos pueden servir\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nlibrary(datarium)\n\ndatos  <- marketing\n```\n:::\n\n\nEstos datos son muy sencillos, son 200 filas y  4 columnas que se corresponden con la inversión \npublicitaria en 3 canales (youtube, facebook, newspaper) y una última columna con el monto de las\nventas. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(datos)\n#> [1] 200   4\nhead(datos)\n#>   youtube facebook newspaper sales\n#> 1  276.12    45.36     83.04 26.52\n#> 2   53.40    47.16     54.12 12.48\n#> 3   20.64    55.08     83.16 11.16\n#> 4  181.80    49.56     70.20 22.20\n#> 5  216.96    12.96     70.08 15.48\n#> 6   10.44    58.68     90.00  8.64\n```\n:::\n\n\nLeyendo la documentación sobre este conjunto de datos se podría asumir que los datos están ordenados \npor fechas, voy a suponer que cada fila corresponde a una semana, así que voy a pegar una variable de semana \ny otra que sea simplemente del 1 al 200. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatos$fecha_arbitraria <- seq.Date(as.Date(\"2020-01-02\"), length.out =200, by = \"week\")\ndatos$semana <- lubridate::week(datos$fecha_arbitraria)\ndatos$time <- 1:200\n\ndatos$mes <- lubridate::month(datos$fecha_arbitraria)\ndatos$anyo <- lubridate::year(datos$fecha_arbitraria)\n\nhead(datos)\n#>   youtube facebook newspaper sales fecha_arbitraria semana time mes anyo\n#> 1  276.12    45.36     83.04 26.52       2020-01-02      1    1   1 2020\n#> 2   53.40    47.16     54.12 12.48       2020-01-09      2    2   1 2020\n#> 3   20.64    55.08     83.16 11.16       2020-01-16      3    3   1 2020\n#> 4  181.80    49.56     70.20 22.20       2020-01-23      4    4   1 2020\n#> 5  216.96    12.96     70.08 15.48       2020-01-30      5    5   1 2020\n#> 6   10.44    58.68     90.00  8.64       2020-02-06      6    6   2 2020\n```\n:::\n\n\nPintamos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndatos  %>%\n  ggplot(aes(fecha_arbitraria, sales)) +\n  geom_point() + \n  geom_line()\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-4-1.png){width=80%}\n:::\n:::\n\n\n\n## Teoría marketiniana\n\nEn estas cosas de marketing mix modelling hay algunas cosillas peculiares. La primera es que se asume, y \nno me parece mal, que en un instante _t_ la inversión publicitaria que \"causa\" las ventas no es sólo la\ndel instante _t_ sino que también hay cierto efecto \"remanente\" de la inversión pasada. Y por tanto en \nvez de considerar la variable tal cual en un instante _t_ se considera algo como \n\n$$ X_{Adstock} = X_t + \\lambda_{1} \\times X_{t-1} + ...\\lambda_{n} \\times X_{t-n} $$\n\npero además vamos a poner un período de _olvido_  de 2 . \n\nEn  R podemos hacerlo de la siguiente forma. \nPor ejemplo para facebook\n\nSe supone que los datos están ordenados de fecha más antigua a más reciente. El criterio de \nponer set_rate_fb = 0.1 ha sido arbitrario, pero se podría estimar.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#set adstock fb rate\nset_rate_fb <- 0.1\nset_memory <- 2\nget_adstock_fb <- rep(set_rate_fb, set_memory+1) ^ c(0:set_memory)\n\nads_fb <- stats::filter(c(rep(0, set_memory), datos$facebook), get_adstock_fb, method=\"convolution\")\nads_fb <- ads_fb[!is.na(ads_fb)]\n\nhead(datos$facebook)\n#> [1] 45.36 47.16 55.08 49.56 12.96 58.68\nhead(ads_fb)\n#> [1] 45.3600 51.6960 60.2496 55.5396 18.4668 60.4716\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\nplot(seq(1,length(datos$facebook)), datos$facebook, type=\"h\", \n     main = \"Adstocked Facebook\",\n     xlab=\"Time (Weeks)\", ylab=\"Facebook\", \n     ylim=c(0, max(c(datos$facebook, ads_fb))), \n     frame.plot=FALSE)\nlines(ads_fb, col=\"blue\")\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-6-1.png){width=80%}\n:::\n:::\n\n\nHacemos lo mismo para resto de canales, con diferente valor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\n#set adstock youtube rate\nset_rate_yt <- 0.15\nset_memory <- 2\nget_adstock_youtube <- rep(set_rate_yt, set_memory+1) ^ c(0:set_memory)\n\n#set adstock news rate\nset_rate_news <- 0.25\nset_memory <- 2\nget_adstock_news <- rep(set_rate_news, set_memory+1) ^ c(0:set_memory)\n\n\nads_youtube <- stats::filter(c(rep(0, set_memory), datos$youtube), get_adstock_youtube, method=\"convolution\")\nads_youtube <- ads_youtube[!is.na(ads_youtube)]\n\n#adstocked newpaper\nads_news <- stats::filter(c(rep(0, set_memory), datos$newspaper), get_adstock_news, method=\"convolution\")\nads_news <- ads_news[!is.na(ads_news)]\n#plot\n\n\ndatos <- cbind(datos, ads_fb, ads_youtube, ads_news)\nhead(datos)\n#>   youtube facebook newspaper sales fecha_arbitraria semana time mes anyo\n#> 1  276.12    45.36     83.04 26.52       2020-01-02      1    1   1 2020\n#> 2   53.40    47.16     54.12 12.48       2020-01-09      2    2   1 2020\n#> 3   20.64    55.08     83.16 11.16       2020-01-16      3    3   1 2020\n#> 4  181.80    49.56     70.20 22.20       2020-01-23      4    4   1 2020\n#> 5  216.96    12.96     70.08 15.48       2020-01-30      5    5   1 2020\n#> 6   10.44    58.68     90.00  8.64       2020-02-06      6    6   2 2020\n#>    ads_fb ads_youtube ads_news\n#> 1 45.3600    276.1200  83.0400\n#> 2 51.6960     94.8180  74.8800\n#> 3 60.2496     34.8627 101.8800\n#> 4 55.5396    186.0975  94.3725\n#> 5 18.4668    244.6944  92.8275\n#> 6 60.4716     47.0745 111.9075\n```\n:::\n\n\n\n## Modelando\n\nPues en esta primera parte de MMM estilo compadre se trata simplemente de estimar las ventas en base al tiempo y al \nadstock, es decir, un ejercicio de estimación de series temporales. De hecho, las consultoras que se dedican \na estos temas hacen una serie de modelos lineales, a veces encadenados (y sin ajustar conjuntamente, lo cual \nes un error importante), y algunas asumen modelos lineales sin _Intercept_ , es decir, tienen la asunción \nfuerte (y errónea) que todas las ventas se deben exclusivamente a variables modeladas y que a inversión 0, las ventas\nno existen. Yo no voy a asumir semejante cosa, dios me libre.\n\n\n### Primer modelo sencillito\n\nPues ya que el software lo permite, vamos a hacer un modelito, pero bayesiano.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nlibrary(cmdstanr)\nlibrary(brms)\n```\n:::\n\n\nEn vez de modelar las ventas , modelo su logaritmo neperiano, por qué? porque me da la gana, y porque a veces\nasí se consiguen mejores resultados. En realidad habría que probar ambas cosas. \n \nTambién meto un término de splines, y entreno con los primeros 150 datos y dejo de test los últimos 50\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ntrain <- datos[1:150, ]\ntest <-  datos[151:200, ]\n\n\nmod_splines <- brm(log(sales) ~ ads_fb + ads_youtube + ads_news  + s(time, k = 10),\n              data = train,\n              family = gaussian(), backend = \"cmdstanr\",cores = 4, file = here::here(\"2024/05/mod_splines\") )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\nsummary(mod_splines)\n#>  Family: gaussian \n#>   Links: mu = identity; sigma = identity \n#> Formula: log(sales) ~ ads_fb + ads_youtube + ads_news + s(time, k = 10) \n#>    Data: train (Number of observations: 150) \n#>   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n#>          total post-warmup draws = 4000\n#> \n#> Smoothing Spline Hyperparameters:\n#>              Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n#> sds(stime_1)     0.23      0.24     0.01     0.90 1.00     1073     1853\n#> \n#> Regression Coefficients:\n#>             Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n#> Intercept       1.82      0.05     1.72     1.92 1.00     4104     3225\n#> ads_fb          0.01      0.00     0.01     0.01 1.00     4061     2383\n#> ads_youtube     0.00      0.00     0.00     0.00 1.00     4301     2832\n#> ads_news        0.00      0.00    -0.00     0.00 1.00     4466     3017\n#> stime_1         0.06      0.50    -0.86     1.33 1.00     1313     1086\n#> \n#> Further Distributional Parameters:\n#>       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n#> sigma     0.20      0.01     0.18     0.23 1.00     3540     2808\n#> \n#> Draws were sampled using sample(hmc). For each parameter, Bulk_ESS\n#> and Tail_ESS are effective sample size measures, and Rhat is the potential\n#> scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n\n### Algún chequeo del modelo\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(mod_splines, ndraws  = 100)\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-11-1.png){width=80%}\n:::\n:::\n\n\ny no tiene mala pinta. \n\nVeamos en test\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\npredicciones <- posterior_predict(mod_splines, newdata = test, ndraws = 1000)\npredicciones_medias <- apply(predicciones, 2, mean)\n\ntest$ventas_predichas <- predicciones_medias\n\nyardstick::rmse_vec(test$sales, exp(test$ventas_predichas))\n#> [1] 2.490994\n\n\ntest  %>%\n  ggplot(aes(x = exp(ventas_predichas), y = sales)) +\n  geom_point()  +\n  geom_abline(intercept = 0, slope = 1)\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-12-1.png){width=80%}\n:::\n:::\n\n\nY bueno, ni tan mal. \n\n## Optimizando\n\nPues el tema en esto del MMM consiste ahora en encontrar cuánto hay que invertir en cada\ncanal para optimizar las ventas , pero sujeto a unas restricciones, por ejemplo presupuestarias.\n\nTodo esto con la asunción de que el modelo ajustado representa la verdadera relación causal\ny no sólo asociación. \n\nEl principal problema que yo veo a estas cosas es que si yo he entrenado con un rango de gasto\nhistórico en un canal A, el modelo puede haber estimado que a más gasto más ventas y extrapolar\nmucho más allá de lo aconsejable.\n\n\nLo primero es crear una función que simule las ventas obtenidas. \n\nSuponemos que nuestros nuevos datos irán temporalmente detrás de los datos de train, y que por tanto \nel adstock se ve influido por datos antiguos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nsimular_ventas_siguiente_periodo <- function(facebook_new, youtube_new, news_new,  modelo) {\n \n  nuevo_time = max(train$time) + 1\n  \n  # obtener add_stock \n  ads_fb <- stats::filter(c(rep(0, set_memory), train$facebook, facebook_new), get_adstock_fb, method=\"convolution\")\n  ads_fb <- ads_fb[!is.na(ads_fb)]\n  ads_fb <-  tail(ads_fb, 1)\n  \n  \n  ads_youtube <- stats::filter(c(rep(0, set_memory), train$youtube, youtube_new), get_adstock_youtube, method=\"convolution\")\n  ads_youtube <- ads_youtube[!is.na(ads_youtube)]\n  ads_youtube <-  tail(ads_youtube, 1)\n  \n  \n  ads_news <- stats::filter(c(rep(0, set_memory), train$newspaper, news_new), get_adstock_news, method=\"convolution\")\n  ads_news <- ads_news[!is.na(ads_news)]\n  ads_news <-  tail(ads_news, 1)\n  \n  newdata = data.frame(ads_fb = ads_fb, ads_youtube = ads_youtube, ads_news = ads_news, time = nuevo_time)\n  \n # estimamos con el modelo  \n  ventas_simuladas <- posterior_predict(modelo, newdata = newdata, ndraws = 500)\n \n  return(as.numeric(ventas_simuladas))\n}\n```\n:::\n\n\nLa probamos, incrementando en 1% la media de gasto en train\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfacebook_new <-  mean(train$facebook) * 1.01\nyoutube_new <-  mean(train$youtube) * 1.01\nnews_new <-  mean(train$newspaper) * 1.01\n\nsimulaciones <- simular_ventas_siguiente_periodo(facebook_new, youtube_new, news_new,  mod_splines)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\nsimulaciones %>% \n  as_tibble() %>% \n  ggplot(aes(x = exp(value))) +\n  geom_density() +\n  labs(title = \"Distribución de ventas esperadas\",\n       x = \"Ventas esperadas\",\n       y = \"Densidad\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-15-1.png){width=80%}\n:::\n:::\n\n\n\nBien, pues ahora tenemos que construir la función a optimizar. Vamos a poner un presupuesto máximo de 450. \nY en la función a optimizar añadimos una penalización alta si la suma de los valores a optimizar supera este\npresupuesto. Aparte de este valor máximo también vamos a poner umbrales al valor mínimo y máximo del gasto en cada \ncanal. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfuncion_objetivo <- function(facebook_new, youtube_new, news_new, modelo) {\n  \n  max_suma <- 450\n  penalizacion <- 0\n  \n  # Calcular la suma de los parámetros\n  suma_par <- sum(facebook_new, youtube_new, news_new)\n  \n  # Si la suma de los parámetros supera el valor máximo, añadir una penalización\n  if (suma_par > max_suma) {\n    penalizacion <- 1e6 * (suma_par - max_suma)^2\n  }\n  \n  \n  # facebook_new <- x[1]\n  # youtube_new <- x[2]\n  # news_new <- x[3]\n  time <- 201\n  \n  ventas_simuladas <- simular_ventas_siguiente_periodo(facebook_new, youtube_new, news_new, modelo)\n  \n  # Puedes definir el ROI u otra métrica si lo prefieres\n  ventas_esperadas <- mean(ventas_simuladas)\n  return(list(Score = -ventas_esperadas + penalizacion)) # Negativo para maximizar\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(prueba <- funcion_objetivo(facebook_new, youtube_new, news_new, mod_splines))\n#> $Score\n#> [1] -2.706681\n\n# las ventas serán el exp de menos el resultado\nexp(-prueba$Score)\n#> [1] 14.97948\n```\n:::\n\n\n\n\n\nAhora sería optimizar esa función con algún solver, yo voy a usar una optimización bayesiana y en paralelo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ParBayesianOptimization)\nlibrary(doParallel)\nlibrary(foreach)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Configurar el clúster para usar 5 núcleos\nnum_cores <- 5\ncl <- makeCluster(num_cores)\nregisterDoParallel(cl)\n```\n:::\n\n\n\nLímites de gasto. ¿Por qué pongo estos? Porque quiero, y he añadido que el mínimo en news sea 13 \n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nbounds <- list(\n    facebook_new = c(0, 224)\n  , youtube_new = c(0, 400)\n  , news_new = c(13, 34)\n)\n```\n:::\n\n\nMe creo una función parcial \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf_objetivo_partial  <- partial(funcion_objetivo, modelo = mod_splines)\n```\n:::\n\n \n\nPara hacer la computación en paralelo  hay que copiar las librerías y los datos y funciones en cada \"conexión\", al menos\npara usar esta librería\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclusterEvalQ(cl, {\n  library(ParBayesianOptimization)\n  library(tidyverse)\n  library(brms)\n  })\n#> [[1]]\n#>  [1] \"brms\"                    \"Rcpp\"                   \n#>  [3] \"lubridate\"               \"forcats\"                \n#>  [5] \"stringr\"                 \"dplyr\"                  \n#>  [7] \"purrr\"                   \"readr\"                  \n#>  [9] \"tidyr\"                   \"tibble\"                 \n#> [11] \"ggplot2\"                 \"tidyverse\"              \n#> [13] \"ParBayesianOptimization\" \"stats\"                  \n#> [15] \"graphics\"                \"grDevices\"              \n#> [17] \"utils\"                   \"datasets\"               \n#> [19] \"methods\"                 \"base\"                   \n#> \n#> [[2]]\n#>  [1] \"brms\"                    \"Rcpp\"                   \n#>  [3] \"lubridate\"               \"forcats\"                \n#>  [5] \"stringr\"                 \"dplyr\"                  \n#>  [7] \"purrr\"                   \"readr\"                  \n#>  [9] \"tidyr\"                   \"tibble\"                 \n#> [11] \"ggplot2\"                 \"tidyverse\"              \n#> [13] \"ParBayesianOptimization\" \"stats\"                  \n#> [15] \"graphics\"                \"grDevices\"              \n#> [17] \"utils\"                   \"datasets\"               \n#> [19] \"methods\"                 \"base\"                   \n#> \n#> [[3]]\n#>  [1] \"brms\"                    \"Rcpp\"                   \n#>  [3] \"lubridate\"               \"forcats\"                \n#>  [5] \"stringr\"                 \"dplyr\"                  \n#>  [7] \"purrr\"                   \"readr\"                  \n#>  [9] \"tidyr\"                   \"tibble\"                 \n#> [11] \"ggplot2\"                 \"tidyverse\"              \n#> [13] \"ParBayesianOptimization\" \"stats\"                  \n#> [15] \"graphics\"                \"grDevices\"              \n#> [17] \"utils\"                   \"datasets\"               \n#> [19] \"methods\"                 \"base\"                   \n#> \n#> [[4]]\n#>  [1] \"brms\"                    \"Rcpp\"                   \n#>  [3] \"lubridate\"               \"forcats\"                \n#>  [5] \"stringr\"                 \"dplyr\"                  \n#>  [7] \"purrr\"                   \"readr\"                  \n#>  [9] \"tidyr\"                   \"tibble\"                 \n#> [11] \"ggplot2\"                 \"tidyverse\"              \n#> [13] \"ParBayesianOptimization\" \"stats\"                  \n#> [15] \"graphics\"                \"grDevices\"              \n#> [17] \"utils\"                   \"datasets\"               \n#> [19] \"methods\"                 \"base\"                   \n#> \n#> [[5]]\n#>  [1] \"brms\"                    \"Rcpp\"                   \n#>  [3] \"lubridate\"               \"forcats\"                \n#>  [5] \"stringr\"                 \"dplyr\"                  \n#>  [7] \"purrr\"                   \"readr\"                  \n#>  [9] \"tidyr\"                   \"tibble\"                 \n#> [11] \"ggplot2\"                 \"tidyverse\"              \n#> [13] \"ParBayesianOptimization\" \"stats\"                  \n#> [15] \"graphics\"                \"grDevices\"              \n#> [17] \"utils\"                   \"datasets\"               \n#> [19] \"methods\"                 \"base\"\n  \n  \n  \nclusterExport(cl,c('simular_ventas_siguiente_periodo', 'train','bounds', 'funcion_objetivo','f_objetivo_partial', 'mod_splines', \n                   'set_memory', 'get_adstock_fb', 'get_adstock_youtube', \n                   'get_adstock_news'))\n```\n:::\n\n\n\nY ya podríamos  optimizar\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes_opt <- bayesOpt(\n  FUN = f_objetivo_partial,\n  bounds = bounds,\n  initPoints = 10,\n  acq = \"ei\",\n  iters.n = 200,\n  iters.k = 10,\n  kappa = 2,\n  eps = 0.0, \n  parallel = TRUE,\n  otherHalting = list(timeLimit = 300)\n)\n```\n:::\n\n\n\n\nY los resultados \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mostrar los resultados\nprint(bayes_opt)\n#> Class: bayesOpt\n#> \n#>                     Epochs: 9\n#>                 Iterations: 121\n#>        Average FUN Seconds: 0.25\n#>        Highest FUN Seconds: 0.43\n#> Final Expected Improvement: 1.29451e-196\n#>                 GP Updated: TRUE\n#>                Stop Status: Stopped Early. See $stopStatus\nbayes_opt$scoreSummary %>% \n  arrange(Score) \n#>      Epoch Iteration facebook_new youtube_new news_new     gpUtility acqOptimum\n#>      <num>     <int>        <num>       <num>    <num>         <num>     <lgcl>\n#>   1:     8       109     209.0382   188.26843 34.00000 1.020609e-206      FALSE\n#>   2:     8       107     205.6691   194.69657 34.00000 1.865035e-214      FALSE\n#>   3:     0         7     198.7479   117.12296 20.49307            NA      FALSE\n#>   4:     3        49     224.0000    33.11638 13.00000  2.045357e-10      FALSE\n#>   5:     3        50     224.0000    44.65494 13.00000  4.256401e-12      FALSE\n#>  ---                                                                           \n#> 117:     2        32     220.6160   400.00000 33.62111  1.480956e-01      FALSE\n#> 118:     2        38     224.0000   400.00000 32.09205  1.590753e-01      FALSE\n#> 119:     2        37     223.1593   400.00000 33.79447  1.672941e-01      FALSE\n#> 120:     2        36     224.0000   400.00000 33.25423  1.688293e-01      FALSE\n#> 121:     2        28     224.0000   400.00000 34.00000  1.750704e-01       TRUE\n#>      inBounds Elapsed         Score errorMessage\n#>        <lgcl>   <num>         <num>       <lgcl>\n#>   1:     TRUE   0.289 -4.372599e+00           NA\n#>   2:     TRUE   0.210 -4.363265e+00           NA\n#>   3:     TRUE   0.200 -4.068045e+00           NA\n#>   4:     TRUE   0.248 -4.052501e+00           NA\n#>   5:     TRUE   0.230 -4.049900e+00           NA\n#>  ---                                            \n#> 117:     TRUE   0.379  4.171281e+10           NA\n#> 118:     TRUE   0.181  4.247393e+10           NA\n#> 119:     TRUE   0.296  4.282986e+10           NA\n#> 120:     TRUE   0.250  4.295431e+10           NA\n#> 121:     TRUE   0.186  4.326400e+10           NA\n```\n:::\n\n\nLos valores óptimos que ha encontrado de gasto en cada canal, cumpliendo las restricciones\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(result_bayes <- bayes_opt$scoreSummary %>% \n arrange(Score) %>% \n head(1) %>% \n select(facebook_new, youtube_new, news_new, Score) )\n#>    facebook_new youtube_new news_new     Score\n#>           <num>       <num>    <num>     <num>\n#> 1:     209.0382    188.2684       34 -4.372599\n```\n:::\n\nComprobamos que no se ha pasdo del presupuesto\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(result_bayes, sum(facebook_new, youtube_new, news_new))\n#> [1] 431.3066\n```\n:::\n\n\n\nparo cluster\n\nSimulamos las ventas que se esperan con esta optimización.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulaciones_optim <- simular_ventas_siguiente_periodo(result_bayes$facebook_new, result_bayes$youtube_new, result_bayes$news_new,\n                                                       modelo = mod_splines)\nexp(quantile(simulaciones_optim, c(0.2, 0.5, 0.8)))\n#>      20%      50%      80% \n#> 63.35897 79.21859 96.77963\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n\nsimulaciones_optim %>% \n  as_tibble() %>% \n  ggplot(aes(x = exp(value))) +\n  geom_density() +\n  labs(title = \"Distribución de ventas esperadas tras optimización\",\n       x = \"Ventas esperadas\",\n       y = \"Densidad\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-28-1.png){width=80%}\n:::\n:::\n\n\n\nY básicamente esta sería la idea principal de hacer un MMM.\n\n\n## Curvas de saturación y como modelarlas\n\nSin embargo también se considera el concepto de curva de saturación, \nque no es más que la asunción de que llega un momento en que por más que te gastes en publicidad, no vas a tener más ventas. \n\n\nPor ejemplo, para eso veamos si eso se ve en los datos \n\n\nCon los datos reales y gastos en youtube se intuye que  podría existir más allá del \ndominio observado de la variable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(p_youtube_real <- datos %>% \n  group_by(ads_youtube) %>%\n  summarise(ventas_mean = mean(sales)) %>%\n  ggplot(aes(x = ads_youtube, y = ventas_mean)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(limits = c(0, 400)) +\n  labs(title = \"Curva real en los datos\",\n       x = \"Gasto en youtube\",\n       y = \"Ventas\"))\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-29-1.png){width=80%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(p_facebook_real <- datos %>% \n  group_by(ads_fb) %>%\n  summarise(ventas_mean = mean(sales)) %>%\n  ggplot(aes(x = ads_fb, y = ventas_mean)) +\n  geom_point() +\n  geom_smooth() +\n  scale_x_continuous(limits = c(0, 100)) +\n  labs(title = \"Curva real en los datos\",\n       x = \"Gasto en facebook\",\n       y = \"Ventas\"))\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-30-1.png){width=80%}\n:::\n:::\n\n\n\n\n###  Podemos suponer una función para las curvas de saturación\n\nA refactorizar----\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nhill_adstock_formula <- bf(\n  log(sales) ~ bfb * ads_fb ^ hfb  / (hillfb^hfb + ads_fb ^ hfb)  +\n    byoutube * ads_youtube ^ hyou / (hillyoutube^hyou + ads_youtube ^ hyou) +\n    bnews * ads_news ^ hnews / (hillnews^hnews + ads_news ^ hnews) + btime * time, \n  bfb + hillfb + byoutube + hillyoutube + bnews + hillnews + btime + hfb + hyou + hnews ~ 1,\n  nl = TRUE\n)\n\n# Define los priors para los parámetros del modelo\n\npriors <- c(\n  prior(normal(0, 10), nlpar = \"bfb\", lb = 0),\n  prior(normal(0, 10), nlpar = \"hillfb\"),\n  prior(normal(0, 10), nlpar = \"byoutube\", lb = 0 ),\n  prior(normal(0, 50), nlpar = \"hillyoutube\"),\n  prior(normal(0, 50), nlpar = \"bnews\", lb = -0.1),\n  prior(normal(0, 50), nlpar = \"hillnews\"),\n  prior(normal(0, 50), nlpar = \"btime\", lb = 0),\n  prior(lognormal(log(1), 0.5), nlpar = \"hfb\", lb = 0),\n  prior(lognormal(log(1), 0.5), nlpar = \"hyou\", lb = 0),\n  prior(lognormal(log(1), 0.5), nlpar = \"hnews\", lb = 0)\n)\n\n\n\n# Ajusta el modelo con brms\n\nmodelo_hill_adstock <- brm(\n  formula = hill_adstock_formula,\n  data = datos,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, iter = 4000, warmup = 1000, \n  control = list( adapt_delta = 0.95),\n  backend = \"cmdstanr\",cores = 4, file = here::here(\"2024/05/mod_hill\") \n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Muestra un resumen del modelo\nsummary(modelo_hill_adstock)\n#>  Family: gaussian \n#>   Links: mu = identity; sigma = identity \n#> Formula: log(sales) ~ bfb * ads_fb^hfb/(hillfb^hfb + ads_fb^hfb) + byoutube * ads_youtube^hyou/(hillyoutube^hyou + ads_youtube^hyou) + bnews * ads_news^hnews/(hillnews^hnews + ads_news^hnews) + btime * time \n#>          bfb ~ 1\n#>          hillfb ~ 1\n#>          byoutube ~ 1\n#>          hillyoutube ~ 1\n#>          bnews ~ 1\n#>          hillnews ~ 1\n#>          btime ~ 1\n#>          hfb ~ 1\n#>          hyou ~ 1\n#>          hnews ~ 1\n#>    Data: datos (Number of observations: 200) \n#>   Draws: 4 chains, each with iter = 4000; warmup = 1000; thin = 1;\n#>          total post-warmup draws = 12000\n#> \n#> Regression Coefficients:\n#>                       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\n#> bfb_Intercept             0.69      0.09     0.55     0.89 1.00     1403\n#> hillfb_Intercept         34.81      3.61    28.82    43.17 1.00     1770\n#> byoutube_Intercept        3.20      0.14     2.94     3.48 1.02      236\n#> hillyoutube_Intercept    37.09      3.45    32.17    45.11 1.00     1612\n#> bnews_Intercept          -0.01      0.07    -0.10     0.17 1.01      353\n#> hillnews_Intercept       37.39     31.82     0.91   114.61 1.02      275\n#> btime_Intercept           0.00      0.00     0.00     0.00 1.01      706\n#> hfb_Intercept             2.60      0.43     1.88     3.53 1.01     1900\n#> hyou_Intercept            0.84      0.08     0.68     1.00 1.01      749\n#> hnews_Intercept           1.08      0.59     0.34     2.63 1.00     1659\n#>                       Tail_ESS\n#> bfb_Intercept             2596\n#> hillfb_Intercept          2536\n#> byoutube_Intercept          71\n#> hillyoutube_Intercept     1166\n#> bnews_Intercept            106\n#> hillnews_Intercept         126\n#> btime_Intercept           1048\n#> hfb_Intercept             3240\n#> hyou_Intercept            1219\n#> hnews_Intercept           3197\n#> \n#> Further Distributional Parameters:\n#>       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n#> sigma     0.13      0.01     0.12     0.14 1.01      326       89\n#> \n#> Draws were sampled using sample(hmc). For each parameter, Bulk_ESS\n#> and Tail_ESS are effective sample size measures, and Rhat is the potential\n#> scale reduction factor on split chains (at convergence, Rhat = 1).\npp_check(modelo_hill_adstock, ndraws = 100)\n```\n\n::: {.cell-output-display}\n![](mmm_estilo_compadre_files/figure-html/unnamed-chunk-32-1.png){width=80%}\n:::\n\n```{.r .cell-code}\n\nloo(modelo_hill_adstock)\n#> \n#> Computed from 12000 by 200 log-likelihood matrix.\n#> \n#>          Estimate   SE\n#> elpd_loo    113.7 41.6\n#> p_loo        26.0 17.8\n#> looic      -227.4 83.2\n#> ------\n#> MCSE of elpd_loo is NA.\n#> MCSE and ESS estimates assume MCMC draws (r_eff in [0.0, 0.6]).\n#> \n#> Pareto k diagnostic values:\n#>                          Count Pct.    Min. ESS\n#> (-Inf, 0.7]   (good)     199   99.5%   39      \n#>    (0.7, 1]   (bad)        0    0.0%   <NA>    \n#>    (1, Inf)   (very bad)   1    0.5%   <NA>    \n#> See help('pareto-k-diagnostic') for details.\n## testeo sobre datos nuevos \n\npred_test <-  posterior_predict(modelo_hill_adstock, newdata = test)\n\npred_test_medias <- apply(pred_test, 2, mean)\n\nyardstick::rmse_vec(test$sales, exp(pred_test_medias))\n#> [1] 1.41478\n\n\npredicciones <- posterior_predict(modelo_hill_adstock, newdata = datos, ndraws = 1000) \n\n# Calcular las predicciones medias\npredicciones_medias <- apply(predicciones, 2, mean)\n\n# Agregar las predicciones al dataframe de nuevos datos\ndatos$ventas_predichas <- exp(predicciones_medias)\n\n\n# Curva de saturación para publicidad\n\np_youtube_estimada <- datos %>% \n  group_by(ads_youtube) %>%\n  summarise(ventas_predichas_mean = median(ventas_predichas),\n            low = quantile(ventas_predichas, 0.05), \n            high = quantile(ventas_predichas, 0.95)) %>%\n  ggplot(aes(x = ads_youtube, y = ventas_predichas_mean)) +\n  geom_line() +\n  geom_ribbon(aes(ymin = low, ymax = high), alpha = 0.3) +\n  labs(title = \"Curva de Saturación para Youtube\",\n       x = \"Gasto en Youtube\",\n       y = \"Ventas Predichas\")\n```\n:::\n\n\nTambién podemos crear un dataset sintético con grid de combinaciones\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crear un rango de valores para publicidad y promociones\nads_fb <- seq(0, 400, length.out = 30)\nads_youtube <- seq(0, 400, length.out = 30)\nads_news <- seq(0, 400, length.out = 30)\ntime <-  rep(201, 30)\n\n# Crear un nuevo dataframe para predicciones\nnuevos_datos <- expand.grid(\n  ads_fb = ads_fb,\n  ads_youtube = ads_youtube,\n  ads_news = ads_news,\n  time = time\n) \n\n# son demasiados datos , tomo una muestra, que no es pecado\ndim(nuevos_datos)\n#> [1] 810000      4\n\nnuevos_datos <-  nuevos_datos %>% \n  sample_n(4000)\npredicciones <- posterior_predict(modelo_hill_adstock, newdata = nuevos_datos, ndraws = 1000) \n\n# Calcular las predicciones medias\npredicciones_medias <- apply(predicciones, 2, mean)\n\n# Agregar las predicciones al dataframe de nuevos datos\nnuevos_datos$ventas_predichas <- exp(predicciones_medias)\n\n\n# Curva de saturación para publicidad\n\np_youtube_estimada_bis <- nuevos_datos %>% \n  group_by(ads_youtube) %>%\n  summarise(ventas_predichas_mean = median(ventas_predichas),\n            low = quantile(ventas_predichas, 0.05), \n            high = quantile(ventas_predichas, 0.95)) %>%\n  ggplot(aes(x = ads_youtube, y = ventas_predichas_mean)) +\n  geom_line() +\n  geom_ribbon(aes(ymin = low, ymax = high), alpha = 0.3) +\n  labs(title = \"Curva de Saturación para Youtube\",\n       x = \"Gasto en Youtube\",\n       y = \"Ventas Predichas\")\n\n```\n:::\n",
    "supporting": [
      "mmm_estilo_compadre_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}