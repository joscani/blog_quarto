{
  "hash": "0ee310774955d86376c21b2b292b1683",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Sin sentidos\ndate: '2025-08-15'\ncategories: \n  - estadística\n  - ciencia de datos\n  - \"2025\"\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\n  output: true\nformat: \n  html: \n    toc: true\n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8\n    fig-align: center\n    code-fold: show\n    code-link: true\n    code-summary: \"Show the code\"\n    code-tools: true \nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n---\n\n\n::: callout-note\n## Listening\n\n<iframe style=\"border-radius:12px\" src=\"https://open.spotify.com/embed/track/4mqbTmpIvq8n0JjngQeowg?utm_source=generator\" width=\"100%\" height=\"352\" frameBorder=\"0\" allowfullscreen=\"\" allow=\"autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture\" loading=\"lazy\">\n</iframe>\n:::\n\nEn un tiempo no muy lejano del cual estoy intentando olvidarme oí hablar de lo que yo llamo \"gatillos\" o como les gusta decir a algunos \"triggers\" ( lo de gatillos viene de derivar triggers a tigres y luego a gatillos, que encima tiene que ver con disparar) \n\nEs una cosa muy sencilla, si se da un eventoA entonces mando a la gente que tiene ese evento a campaña 1, y se da eventoB mando a esos a campaña 2. \n\nHasta aquí todo más o menos bien, pero como pensaría cualquier persona normal, ¿ si tener el eventoA o tener el eventoB aumentan la probabilidad de comprar el mismo producto, por qué no meter esos eventos en un modelo, de forma que pille las interacciones y así seleccionar a los más propensos a comprar el producto?\nPues os prometo que me miraban con cara de estupor, sin entender  el por qué eso iba a ser mejor. Visto con cierta distancia, la verdad es que no creo que no se entendiera, sino que simplemente no se quería cambiar nada y que cualquier propuesta que viniera de determinada gente, simplemente se ignoraba o se consideraba errónea. Un sinsentido. \n\n\nUn poco de código para ejemplificar. \n\nGeneramos unos datos dónde tenemos EventoA (1,0), EventoB (1,0) y una variable target que está relacionada positivamente con ambos eventos, por lo cual es lógico pensar que las observaciones que tienen ambos eventos estarán aún más relacionadas con la target. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nset.seed(123)\n\nn <- 1000\n\nEvento1 <- rbinom(n, size = 1, prob = 0.7) \nEvento2 <- rbinom(n, size = 1, prob = 0.6) \n\np_target <- ifelse(Evento1 == 1, 0.7, 0.2)\n\np_target <- p_target + ifelse(Evento2 == 1, 0.3, -0.05)\np_target <- pmin(pmax(p_target, 0.01), 0.99) # limitar entre 0 y 1\n\n# Simular target \ntarget <- rbinom(n, size = 1, prob = p_target)\n\ndf <- data.frame(Evento1, Evento2, target)\n\nhead(df)\n#>   Evento1 Evento2 target\n#> 1       1       1      1\n#> 2       0       1      0\n#> 3       1       1      1\n#> 4       0       0      0\n#> 5       0       0      0\n#> 6       1       1      1\n```\n:::\n\n\nComprobamos que efectivamente es así \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comprobar proporciones\nprop.table(table(df$target, df$Evento1), margin = 2)\n#>    \n#>             0         1\n#>   0 0.6067797 0.1531915\n#>   1 0.3932203 0.8468085\nprop.table(table(df$target, df$Evento2), margin = 2)\n#>    \n#>             0         1\n#>   0 0.5077720 0.1482085\n#>   1 0.4922280 0.8517915\n\n\ndf |>\n  group_by(Evento1, Evento2) |>\n  summarise(\n    mean(target)\n  )\n#> # A tibble: 4 × 3\n#> # Groups:   Evento1 [2]\n#>   Evento1 Evento2 `mean(target)`\n#>     <int>   <int>          <dbl>\n#> 1       0       0          0.179\n#> 2       0       1          0.525\n#> 3       1       0          0.620\n#> 4       1       1          0.991\n```\n:::\n\nY como no podía ser de otra manera, la interacción (tener ambos eventos) tiene una mayor proporción de target=1 que cada evento por separado\n\n\nPues simplemente haber hecho un modelo donde entraran los \"gatillos\" habría sido mucho mejor que simplemente considerar por separado. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_eff_princ <- glm(target ~ Evento1 + Evento2, data = df, family = binomial)\nm_eff_interacc <- glm(target ~ Evento1 * Evento2, data = df, family = binomial)\n\n\nsummary(m_eff_princ)\n#> \n#> Call:\n#> glm(formula = target ~ Evento1 + Evento2, family = binomial, \n#>     data = df)\n#> \n#> Coefficients:\n#>             Estimate Std. Error z value Pr(>|z|)    \n#> (Intercept)  -2.3737     0.2370  -10.02   <2e-16 ***\n#> Evento1       3.0308     0.2338   12.96   <2e-16 ***\n#> Evento2       2.7037     0.2313   11.69   <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for binomial family taken to be 1)\n#> \n#>     Null deviance: 1198.89  on 999  degrees of freedom\n#> Residual deviance:  792.41  on 997  degrees of freedom\n#> AIC: 798.41\n#> \n#> Number of Fisher Scoring iterations: 5\n\nsummary(m_eff_interacc)\n#> \n#> Call:\n#> glm(formula = target ~ Evento1 * Evento2, family = binomial, \n#>     data = df)\n#> \n#> Coefficients:\n#>                 Estimate Std. Error z value Pr(>|z|)    \n#> (Intercept)      -1.5261     0.2467  -6.185 6.19e-10 ***\n#> Evento1           2.0175     0.2763   7.300 2.87e-13 ***\n#> Evento2           1.6245     0.2877   5.646 1.64e-08 ***\n#> Evento1:Evento2   2.5546     0.5921   4.314 1.60e-05 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> (Dispersion parameter for binomial family taken to be 1)\n#> \n#>     Null deviance: 1198.89  on 999  degrees of freedom\n#> Residual deviance:  767.55  on 996  degrees of freedom\n#> AIC: 775.55\n#> \n#> Number of Fisher Scoring iterations: 7\n```\n:::\n\n\nSiiii, ya sé que es un post muy ponto y fácil, pero es que muchas veces me encuentro con gente que no sabe qué es una interacción (aunque usen constantemente xgboost, que es una glorificación de la interacción). \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}