{
  "hash": "1f646d58350e6061ddbb74fd520355b4",
  "result": {
    "markdown": "---\ntitle: AUC = Wilcoxon , de nuevo\nauthor: jlcr\ndate: '2021-03-08'\nslug: auc-wilcoxon-de-nuevo\ncategories:\n  - estadística\n  - 2021\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\n    code-fold: show\n    code-summary: \"Mostrar / ocultar código\"\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n---\n\n\nAnda la gente que si viendo a ver cómo calcular el AUC (roc), que si cómo se hace en spark o que si hay que tener en cuenta muchos puntos de corte y ver las tablas de clasificación asociadas. Eso está bien para contarlo, pero no para calcularlo.\n\nEl AUC se puede considerar como la probabilidad de que el score de un \"sí\" elegido al azar es mayor que el score de un \"no\" elegido al azar. No lo digo yo, lo  cuenta mucho mejor que yo , Carlos en su entrada [AUC = WILCOXON](https://www.datanalytics.com/2019/02/11/auc-wilcoxon/). \nDe hecho, voy a coger sus mismos datos, salvo por la semilla, que no la indica. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(45)\nn <- 30\n\nsi <- data.frame(res = \"si\", score = rnorm(n, 1, 1))\nno <- data.frame(res = \"no\", score = rnorm(n, 0, 1))\n\ndat <- rbind(si, no)\n```\n:::\n\n\nY como bien comenta Carlos, tanto Wilcoxon como el cálculo usual del AUC dan esa probabilidad.  Para esto da igual que los scores sean incluso negativo, se trata de algo que da un orden.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncar::some(dat)\n#>    res      score\n#> 1   si  1.3407997\n#> 2   si  0.2966597\n#> 7   si  0.4986218\n#> 9   si  2.8090374\n#> 12  si  1.2159889\n#> 34  no  0.2854323\n#> 40  no  0.2459699\n#> 48  no -0.3504094\n#> 53  no  0.1114906\n#> 60  no -0.8165108\n```\n:::\n\nY copiando de su blog\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <- wilcox.test(score ~ res, data = dat)$statistic\n# pongo el 1- pq salia menor que 0.5\n1- test / n^2\n#>         W \n#> 0.7122222\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pROC)\nmy_roc <- roc(dat$res, dat$score)\nauc(my_roc)\n#> Area under the curve: 0.7122\n```\n:::\n\n\nPero también podemos hacerlo muestreando.\n\nNos creamos función \n\n\n::: {.cell}\n\n```{.r .cell-code}\netiquetas <- dat$res==\"si\"\ntable(etiquetas)\n#> etiquetas\n#> FALSE  TRUE \n#>    30    30\n```\n:::\n\nAhora muestreamos con reemplazamiento los scores correspondientes a etiqueta = TRUE, es decir a los sis\n\n\n::: {.cell}\n\n```{.r .cell-code}\npos <- sample(dat$score[etiquetas], size = 1e7, replace = TRUE)\nneg <- sample(dat$score[!etiquetas], size = 1e7, replace = TRUE)\n```\n:::\n\n\nY simplemente calculamos la probabilidad que buscamos haciendo la proporción de  la veces qeu el score de un positivo gana al de un negativo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(pos>neg)\n#> [1] 0.7122233\n```\n:::\n\nY es una buena aproximación, creemos función y pongamos que en caso de empate de score, ni pa ti ni pa mi. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauc_probability <- function(labels, scores, N=1e7){\n  pos <- sample(scores[labels], N, replace=TRUE)\n  neg <- sample(scores[!labels], N, replace=TRUE)\n  (sum(pos > neg) + sum(pos == neg)/2) / N\n}\n```\n:::\n\n\nPues ya tenemos una forma \"sencilla\" de calcular auc's, que se puede usar por ejemplo en sql. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nauc_probability(etiquetas, dat$score, N= 1e6)\n#> [1] 0.712108\n```\n:::\n\nSalud y buena tarde\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}