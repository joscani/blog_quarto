{
  "hash": "c7f14e7e5d08a66145f72c8d8e6cc2b7",
  "result": {
    "markdown": "---\ntitle: ¿A dónde va Vicente?\nauthor: jlcr\ndate: '2021-11-01'\nslug: a-dónde-va-vicente\ncategories:\n  - árboles\n  - ciencia de datos\n  - h2o\n  - estadísticca\n  - 2021\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n    \n---\n\n::: {.cell}\n\n:::\n\n\n\nCuando estamos haciendo un modelo y tratamos con variables categóricas como predictoras,  hay que ser muy cuidadoso. Por ejemplo hay que tener en cuenta qué pasa cuándo tenemos un nuevo nivel en el conjunto de datos a predecir que no estaba en el de entrenamiento. Por ejemplo, si estoy utilizando un algoritmo moderno tipo xgboost, y tengo como variable predictora la provincia. ¿Qué pasa si en el conjunto de entrenamiento no tengo datos de \"Granada\", pero en el de predicción si?  \n\nEn el xgboost por defecto las categóricas se codifican con  One-Hot encoder, por lo que al no tener datos de Granada en entrenamiento a la hora de predecir la fila de Granada siempre va a tirar hacia el 0, por ejemplo, un corte en uno de los árboles podría ser Almeria = 0  para la izquierda y Almeria = 1 para la derecha. Esto es lo que suelen hacer la mayoría de las implementaciones. Pero cabe preguntarse si es la mejor solución. Otra alternativa podría ser, dado que tengo que predecir para un nivel no visto en entrenamiento, podría asignarle el valor del target que había en el nodo superior. Esta decisión plantea el problema de como sigues el proceso de partición de datos del árbol. Otra posible decisión podría ser recorrer todos los caminos posibles y promediar. En el caso anterior sería ver qué predicción acaba teniendo cuando Almería = 0 y cuando Almería = 1 y promediar. Sería una solución más justa, aunque plantea el problema de tener que recorrer más ramas. \n\nOtra solución es en cada corte que implique a la variable categórica en cuestión, tirar hacia dónde van la mayoría de los caso \"¿a dónde va Vicente? A dónde va la gente\". Esta es la solución que tiene la gente de [h2o](https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/gbm-faq/missing_values.html) en su implementación de los Random Forest o de los Gradient Boosting.  Dicen textualmente. \n\n> __What happens when you try to predict on a categorical level not seen during training?__\nUnseen categorical levels are turned into NAs, and thus follow the same behavior as an NA. If there are no NAs in the training data, then unseen categorical levels in the test data follow the majority direction (the direction with the most observations). If there are NAs in the training data, then unseen categorical levels in the test data follow the direction that is optimal for the NAs of the training data.\n\n## Ejemplo\n\n### Iniciamos h2o y cargamos datos \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Not run: \nlibrary(h2o)\nh2o.init( max_mem_size = \"25G\")\n#>  Connection successful!\n#> \n#> R is connected to the H2O cluster: \n#>     H2O cluster uptime:         4 minutes 48 seconds \n#>     H2O cluster timezone:       Europe/Madrid \n#>     H2O data parsing timezone:  UTC \n#>     H2O cluster version:        3.38.0.1 \n#>     H2O cluster version age:    1 month and 28 days  \n#>     H2O cluster name:           H2O_started_from_R_jose_ltm884 \n#>     H2O cluster total nodes:    1 \n#>     H2O cluster total memory:   21.82 GB \n#>     H2O cluster total cores:    12 \n#>     H2O cluster allowed cores:  12 \n#>     H2O cluster healthy:        TRUE \n#>     H2O Connection ip:          localhost \n#>     H2O Connection port:        54321 \n#>     H2O Connection proxy:       NA \n#>     H2O Internal Security:      FALSE \n#>     R Version:                  R version 4.2.2 Patched (2022-11-10 r83330)\n```\n:::\n\n\nImportamos los datos del titanic. Ponemos como variables predictoras de la supervivencia,  solo la clase y el sexo. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nf <- \"https://s3.amazonaws.com/h2o-public-test-data/smalldata/gbm_test/titanic.csv\"\ntitanic <- h2o.importFile(f)\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======                                                                |   8%\n  |                                                                            \n  |======================================================================| 100%\n\ntitanic['survived'] <- as.factor(titanic['survived'])\npredictors <- c(\"pclass\",\"sex\")\nresponse <- \"survived\"\n\n# convertimos la clase a factor \ntitanic$pclass <- as.factor(titanic$pclass)\nh2o.getTypes(titanic$pclass)\n#> [[1]]\n#> [1] \"enum\"\n```\n:::\n\n\nPartimos en train y test \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplits <- h2o.splitFrame(data =  titanic, ratios = .8, seed = 1234)\ntrain <- splits[[1]]\nvalid <- splits[[2]]\n\nh2o.table(train$pclass)\n#>   pclass Count\n#> 1      1   260\n#> 2      2   223\n#> 3      3   571\n#> \n#> [3 rows x 2 columns]\nh2o.table(train$sex)\n#>      sex Count\n#> 1 female   387\n#> 2   male   667\n#> \n#> [2 rows x 2 columns]\n\nh2o.table(valid$pclass)\n#>   pclass Count\n#> 1      1    63\n#> 2      2    54\n#> 3      3   138\n#> \n#> [3 rows x 2 columns]\n```\n:::\n\n\nY ahora cambio en test para que aparezcan valores en pclass y en sex que no están en train. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nvalid$pclass = h2o.ifelse(valid$pclass == \"3\", \"unknown\", valid$pclass)\nvalid$sex    = h2o.ifelse(valid$sex == \"male\", \"unknown\", valid$sex )\n\n\nh2o.table(valid$pclass)\n#>    pclass Count\n#> 1       1    63\n#> 2       2    54\n#> 3 unknown   138\n#> \n#> [3 rows x 2 columns]\nh2o.table(valid$sex)\n#>       sex Count\n#> 1  female    79\n#> 2 unknown   176\n#> \n#> [2 rows x 2 columns]\n```\n:::\n\n\nPara ver bien qué sucede con los casos en que tenemos nivel nuevo en clase y sexo nos quedamos con el siguiente conjunto de datos a predecir \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <-  valid[valid$pclass== \"unknown\" & valid$sex == \"unknown\",]\ntest\n#>    pclass survived                          name     sex age sibsp parch ticket\n#> 1 unknown        0 Abbott  Master. Eugene Joseph unknown  13     0     2    NaN\n#> 2 unknown        1 Abelseth  Mr. Olaus Jorgensen unknown  25     0     0 348122\n#> 3 unknown        0                Ali  Mr. Ahmed unknown  24     0     0    NaN\n#> 4 unknown        0   Andersen  Mr. Albert Karvin unknown  32     0     0    NaN\n#> 5 unknown        0   Andersson  Mr. Anders Johan unknown  39     1     5 347082\n#> 6 unknown        0    Andreasson  Mr. Paul Edvin unknown  20     0     0 347466\n#>      fare cabin embarked boat body           home.dest\n#> 1 20.2500  <NA>        S  NaN  NaN East Providence  RI\n#> 2  7.6500 F G63        S  NaN  NaN  Perkins County  SD\n#> 3  7.0500  <NA>        S  NaN  NaN                <NA>\n#> 4 22.5250  <NA>        S  NaN  260      Bergen  Norway\n#> 5 31.2750  <NA>        S  NaN  NaN Sweden Winnipeg  MN\n#> 6  7.8542  <NA>        S  NaN  NaN  Sweden Chicago  IL\n#> \n#> [99 rows x 14 columns]\n```\n:::\n\n\n\n### Modelo xgboost \n\n\nHacemos un sólo árbol\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodeloxg<-  h2o.xgboost(\n  seed = 155,\n  x = predictors, \n  y = response,\n  max_depth = 3,\n  training_frame = train,\n  ntrees =1\n)\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n\nY al predecir, nos da un warning que nos dice ¡¡ojo, tengo nuevos niveles que no estaban en train!! . Aún así , no casca y devuelve una predicción \n\n\n::: {.cell}\n\n```{.r .cell-code}\nh2o.predict(modeloxg, test)\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n#>   predict        p0        p1\n#> 1       0 0.6016703 0.3983298\n#> 2       0 0.6016703 0.3983298\n#> 3       0 0.6016703 0.3983298\n#> 4       0 0.6016703 0.3983298\n#> 5       0 0.6016703 0.3983298\n#> 6       0 0.6016703 0.3983298\n#> \n#> [99 rows x 3 columns]\nh2o.predict_leaf_node_assignment(modeloxg, test)\n#>   T1.C1\n#> 1    LL\n#> 2    LL\n#> 3    LL\n#> 4    LL\n#> 5    LL\n#> 6    LL\n#> \n#> [99 rows x 1 column]\n```\n:::\n\n\nPodemos extraer información del árbol  con \n\n\n::: {.cell}\n\n```{.r .cell-code}\narbol_ind_xg <- h2o.getModelTree(model = modeloxg, tree_number = 1)\n\nNodesInfo <-  function(arbol_ind){\n  for (i in 1:length(arbol_ind)) {\n    info <-\n      sprintf(\n        \"Node ID %s has left child node with index %s and right child node with index %s The split feature is %s. The NA direction is %s\",\n        arbol_ind@node_ids[i],\n        arbol_ind@left_children[i],\n        arbol_ind@right_children[i],\n        arbol_ind@features[i], \n        arbol_ind@nas[i]\n      )\n    print(info)\n  }}\n\nNodesInfo(arbol_ind_xg)\n#> [1] \"Node ID 0 has left child node with index 1 and right child node with index 2 The split feature is sex.female. The NA direction is LEFT\"\n#> [1] \"Node ID 1 has left child node with index 3 and right child node with index 4 The split feature is pclass.1. The NA direction is LEFT\"\n#> [1] \"Node ID 2 has left child node with index 5 and right child node with index 6 The split feature is pclass.3. The NA direction is LEFT\"\n#> [1] \"Node ID 3 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 4 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 5 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 6 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n```\n:::\n\n\nY vemos que nos da información de hacia dónde van los NA (los niveles nuevos no vistos en train) y siempre van hacia la izquierda. \n\nPodemos pintar el árbol. [Script](https://github.com/joscani/mi_blog/blob/master/plot_h2o_tree.R)\nY vemos que los NA, siempre van hacia los 0's.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## importo funciones , encontradas por internet, como no, para pintar el árbol\nsource(\"plot_h2o_tree.R\")\n\ntitanicDataTree_XG = createDataTree(arbol_ind_xg)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplotDataTree(titanicDataTree_XG, rankdir = \"TB\")\n```\n:::\n\n\n\n![](xgboost_data_tree.png)\n\n### Modelo h2o.gbm\n\nVeamos qué hace la implementación de h2o.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ngbm_h2o <-  h2o.gbm(\n  seed = 155,\n  x = predictors, \n  y = response,\n  max_depth = 3,\n  distribution = \"bernoulli\",\n  training_frame = train,\n  ntrees = 1\n)\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n\n\nh2o.predict(gbm_h2o, test)\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n#>   predict        p0        p1\n#> 1       0 0.6375663 0.3624337\n#> 2       0 0.6375663 0.3624337\n#> 3       0 0.6375663 0.3624337\n#> 4       0 0.6375663 0.3624337\n#> 5       0 0.6375663 0.3624337\n#> 6       0 0.6375663 0.3624337\n#> \n#> [99 rows x 3 columns]\nh2o.predict_leaf_node_assignment(gbm_h2o, test)\n#>   T1.C1\n#> 1   LLR\n#> 2   LLR\n#> 3   LLR\n#> 4   LLR\n#> 5   LLR\n#> 6   LLR\n#> \n#> [99 rows x 1 column]\n```\n:::\n\n\nY pintando lo mismo \n\n\n::: {.cell}\n\n```{.r .cell-code}\narbol_ind <- h2o.getModelTree(model = gbm_h2o, tree_number = 1)\nNodesInfo(arbol_ind )\n#> [1] \"Node ID 0 has left child node with index 1 and right child node with index 2 The split feature is sex. The NA direction is LEFT\"\n#> [1] \"Node ID 1 has left child node with index 3 and right child node with index 4 The split feature is pclass. The NA direction is LEFT\"\n#> [1] \"Node ID 2 has left child node with index 5 and right child node with index 6 The split feature is pclass. The NA direction is RIGHT\"\n#> [1] \"Node ID 3 has left child node with index 7 and right child node with index 8 The split feature is pclass. The NA direction is RIGHT\"\n#> [1] \"Node ID 11 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 12 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 6 has left child node with index 9 and right child node with index 10 The split feature is pclass. The NA direction is RIGHT\"\n#> [1] \"Node ID 13 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 14 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 15 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n#> [1] \"Node ID 16 has left child node with index -1 and right child node with index -1 The split feature is NA. The NA direction is NA\"\n```\n:::\n\n\n\nAl pintar vemos un par de cosas curiosas, en primer lugar, h2o.gbm no ha codificado con one-hot las variables categóricas, esto permite por ejemplo que se pueden obtener reglas de corte como Izquierda:(Madrid, Barcelona, Valencia), Derecha: (resto de provincias), mientras que One Hot ese tipo de partición requiere más profundidad en el árbol.  Y en segundo lugar vemos que por ejemplo los NA's (y los nuevos niveles en test) de la variable _pclass_ en un nodo van junto con p_class (2,3), en otro junto con p_class=1 y en otro junto p_class=3.  El criterio elegido es en cada corte, los Nas y por ende los nuevos niveles no vistos en train van hacia dónde va la gente. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntitanicDataTree = createDataTree(arbol_ind)\nplotDataTree(titanicDataTree, rankdir = \"TB\")\n```\n:::\n\n\n![](h2o_gbm_datatree.png)\nY nada más. hasta otra.\n\nNota: Los valores de prediction que saca plotDataTree no son las predicciones del modelo, sino las raw que saca ese árbol en particular. Como en los modelos de gradient boosting se va construyendo cada árbol sobre los errores del anterior, ni siquiera es la probabilidad en escala logit. He buscado en la docu de h2o pero no está claro qué  es este valor. Eso sí, las ramas en el árbol están bien. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}