{
  "hash": "335a205522925177fafff1408ff36d7a",
  "result": {
    "markdown": "---\ntitle: Imputando datos. La estructura importa\ndate: '2021-06-13'\nslug: imputando-datos-la-estructura-importa\ncategories:\n  - estadística\n  - imputación\n  - 2021\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n---\n\n\n\nVoy a empezar este post con un par de citas. \n\n> _El análisis de datos es básicamente encontrar la matriz correcta a diagonalizar._\n\n> _Quien renuncia a la estructura, deja dinero encima de la mesa._\n\nLa primera no recuerdo dónde la leí, pero es de la escuela francesa de estadística, la segunda es del blog hermano [datanalytics](https://www.datanalytics.com/2018/10/04/embeddings-y-analisis-del-carrito-de-la-compra/). \n\nY bueno, ambas tienen parte de razón. En esta entrada voy a comentar brevemente una forma de imputación de datos que quizá a alguien le sea útil.\n\nLa idea básica es: \n\n1. Imputar los valores perdidos por la media de cada variable.\n2. Calcular la estructura factorial con el dataset anterior. \n3. Imputar los valores perdidos por los valores predichos por la estructura factorial. Usando la matriz X reconstruida. \n3. Repetir hasta convergencia.\n\nEste procedimiento iterativo suele usar Expectation Maximization y se conoce como EM-PCA. (también hay versión usando regularización)\n\nMás información en este [artículo](http://www.numdam.org/item/JSFS_2012__153_2_79_0.pdf) de  François Husson\n\n## Ejemplo \n\nY ahora vamos a ver un ejemplito, para eso vamos a usar la librería `missMDA` de François Husson y Julie Josse, que incorpora estos métodos. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(missMDA)\n```\n:::\n\n\nUsamos el conjunto de datos `orange` en cuya ayuda leeemos\n\n*Description*\nSensory description of 12 orange juices by 8 attributes. Some values are missing.\n\n*Usage*\ndata(orange)\n*Format*\nA data frame with 12 rows and 8 columns. Rows represent the different orange juices, columns represent the attributes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(orange)\n```\n:::\n\n\nPor ejemplo, tenemos un valor perdido para la variable `Attack.intensity` en la primera fila\n\n::: {.cell}\n\n```{.r .cell-code}\nDT::datatable(orange,\n               options = list(scrollX = TRUE))\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"htmlwidget-07db65ebd70f37625da3\" style=\"width:100%;height:auto;\" class=\"datatables html-widget\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-07db65ebd70f37625da3\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"],[4.79166666666667,4.58333333333333,4.70833333333333,6.58333333333333,null,6.33333333333333,4.29166666666667,null,4.41666666666667,4.54166666666667,4.08333333333333,6.5],[5.29166666666667,6.04166666666667,5.33333333333333,6,6.16666666666667,5,4.91666666666667,4.54166666666667,null,4.29166666666667,5.125,5.875],[null,4.41666666666667,null,7.41666666666667,5.33333333333333,5.375,5.29166666666667,4.83333333333333,5.16666666666667,null,3.91666666666667,6.125],[null,5.45833333333333,null,4.16666666666667,4.08333333333333,5,5.54166666666667,null,4.625,5.79166666666667,null,4.875],[null,4.125,4.29166666666667,6.75,null,5.5,5.25,4.95833333333333,5.04166666666667,4.375,null,5.29166666666667],[2.83333333333333,3.54166666666667,3.16666666666667,null,4.375,3.625,null,2.91666666666667,3.66666666666667,null,null,4.16666666666667],[null,4.625,6.25,1.41666666666667,3.41666666666667,4.20833333333333,1.29166666666667,1.54166666666667,1.54166666666667,null,7.33333333333333,1.5],[5.20833333333333,4.45833333333333,5.16666666666667,3.41666666666667,4.41666666666667,4.875,4.33333333333333,3.95833333333333,3.95833333333333,5,5.25,3.5]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>Color.intensity<\\/th>\\n      <th>Odor.intensity<\\/th>\\n      <th>Attack.intensity<\\/th>\\n      <th>Sweet<\\/th>\\n      <th>Acid<\\/th>\\n      <th>Bitter<\\/th>\\n      <th>Pulp<\\/th>\\n      <th>Typicity<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"scrollX\":true,\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,2,3,4,5,6,7,8]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\nBien, pues ahora podemos usar el EM-PCA para imputar los valores perdidos teniendo en cuenta la estructura factorial. Usamos el ejemplo que viene en la función. \n\nEstimamos el número de componentes a extraer y usamos la función `imputePCA` que\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestim_ncpPCA(orange)\n#> $ncp\n#> [1] 2\n#> \n#> $criterion\n#>         0         1         2         3         4         5 \n#> 1.0388714 0.9279948 0.5976727 0.7855501 2.0250470 2.6741735\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres_impute <-  imputePCA(orange, ncp=2)\n```\n:::\n\n\nLa función devuelve el conjunto de datos ya imputado\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres_impute$completeObs\n#>    Color.intensity Odor.intensity Attack.intensity    Sweet     Acid   Bitter\n#> 1         4.791667       5.291667         4.077034 5.527352 4.177564 2.833333\n#> 2         4.583333       6.041667         4.416667 5.458333 4.125000 3.541667\n#> 3         4.708333       5.333333         4.158054 5.442936 4.291667 3.166667\n#> 4         6.583333       6.000000         7.416667 4.166667 6.750000 4.702509\n#> 5         6.271605       6.166667         5.333333 4.083333 5.455805 4.375000\n#> 6         6.333333       5.000000         5.375000 5.000000 5.500000 3.625000\n#> 7         4.291667       4.916667         5.291667 5.541667 5.250000 3.214232\n#> 8         4.460613       4.541667         4.833333 5.479128 4.958333 2.916667\n#> 9         4.416667       5.136550         5.166667 4.625000 5.041667 3.666667\n#> 10        4.541667       4.291667         4.176991 5.791667 4.375000 2.735255\n#> 11        4.083333       5.125000         3.916667 5.703297 3.900164 2.815857\n#> 12        6.500000       5.875000         6.125000 4.875000 5.291667 4.166667\n#>        Pulp Typicity\n#> 1  5.711715 5.208333\n#> 2  4.625000 4.458333\n#> 3  6.250000 5.166667\n#> 4  1.416667 3.416667\n#> 5  3.416667 4.416667\n#> 6  4.208333 4.875000\n#> 7  1.291667 4.333333\n#> 8  1.541667 3.958333\n#> 9  1.541667 3.958333\n#> 10 4.026062 5.000000\n#> 11 7.333333 5.250000\n#> 12 1.500000 3.500000\n```\n:::\n\n\n## Extensiones\n\nSe puede hacer imputación múltiple.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# creamos 100 datasets imputados, \n# por defecto usa método bootstrap pero también puede usar una versión bayesiana\nres_mi_impute <- MIPCA(orange, ncp = 2, nboot = 100)\n```\n:::\n\n\nEn el Slot `res.MI` tenemos los datasets imputados\n\n::: {.cell}\n\n```{.r .cell-code}\n# vemos por ejemplo la imputación 3\nres_mi_impute$res.MI[[3]]\n#>    Color.intensity Odor.intensity Attack.intensity    Sweet     Acid   Bitter\n#> 1         4.791667       5.291667         2.918305 6.869451 3.625573 2.833333\n#> 2         4.583333       6.041667         4.416667 5.458333 4.125000 3.541667\n#> 3         4.708333       5.333333         2.403693 6.861525 4.291667 3.166667\n#> 4         6.583333       6.000000         7.416667 4.166667 6.750000 4.701455\n#> 5         6.146539       6.166667         5.333333 4.083333 5.097418 4.375000\n#> 6         6.333333       5.000000         5.375000 5.000000 5.500000 3.625000\n#> 7         4.291667       4.916667         5.291667 5.541667 5.250000 2.974466\n#> 8         4.777501       4.541667         4.833333 4.940791 4.958333 2.916667\n#> 9         4.416667       4.999918         5.166667 4.625000 5.041667 3.666667\n#> 10        4.541667       4.291667         4.673680 5.791667 4.375000 2.185506\n#> 11        4.083333       5.125000         3.916667 6.264218 4.439501 3.627578\n#> 12        6.500000       5.875000         6.125000 4.875000 5.291667 4.166667\n#>        Pulp Typicity\n#> 1  2.870165 5.208333\n#> 2  4.625000 4.458333\n#> 3  6.250000 5.166667\n#> 4  1.416667 3.416667\n#> 5  3.416667 4.416667\n#> 6  4.208333 4.875000\n#> 7  1.291667 4.333333\n#> 8  1.541667 3.958333\n#> 9  1.541667 3.958333\n#> 10 4.090779 5.000000\n#> 11 7.333333 5.250000\n#> 12 1.500000 3.500000\n```\n:::\n\nCuando el conjunto de datos es pequeño, como en este caso (12 filas), podemos ver gráficamente la incertidumbre asociada a la imputación. En la ayuda de la función `plot.MIPCA` se puede consultar lo que significa cada gráfico\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(res_mi_impute)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=80%}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=80%}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-3.png){width=80%}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-4.png){width=80%}\n:::\n\n```\n#> $PlotIndProc\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-5.png){width=80%}\n:::\n\n```\n#> \n#> $PlotDim\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-6.png){width=80%}\n:::\n\n```\n#> \n#> $PlotIndSupp\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-7.png){width=80%}\n:::\n\n```\n#> \n#> $PlotVar\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-8.png){width=80%}\n:::\n:::\n\n\n## Mas extensiones\n\nLa librería que subyace bajo `missMDA` es la conocida `FactoMineR` que permite hacer métodos factoriales (otros nombres para lo mismo serían métodos de componentes principales, reducción de dimensiones, projection pursuit) teniendo en cuenta que las variables sean categóricas (Análisis de correspondencias simple y múltiple) o que haya una mezcla de continuas y categóricas (Análisis factorial para datos mixtos). \n\nUna de las extensiones más útiles a mi modo de ver es la que permite imputar teniendo en cuenta la estructura factorial y también que las observaciones estén asociadas, por ejemplo que tenga una clasificación previa, vía segmentación o un cluster previo. \n\nPor ejemplo podría tener datos de clientes de diferentes provincias de España, unirlo todo en un conjunto de datos dónde tenga la variable que indica de qué provincia es cada cliente y poder obtener una estructura factorial global general y una estructura factorial específica para cada provincia y poder utilizar ambas estructuras para imputar los valores perdidos. Sería una parte general y una parte específica. ¿No os recuerda a los modelos mixtos bayesianos o a la estrategia de de modelo global y particular de [Carlos](https://www.youtube.com/watch?v=oGjcWWITxMI&t=23s) ? \n\n\nBueno, pues todo eso se puede hacer con la librería `missMDA`.  Como ejemplo podemos ver el dataset `ozone`\n\n\n*Description*\nThis dataset contains 112 daily measurements of meteorological variables (wind speed, temperature, rainfall, etc.) and ozone concentration recorded in Rennes (France) during the summer 2001. There are 11 continuous variables and 2 categorical variables with 2 or 4 levels. Some values are missing.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(ozone)\nhead(ozone,6)\n#>          maxO3   T9  T12  T15 Ne9 Ne12 Ne15     Vx9    Vx12    Vx15 maxO3v\n#> 20010601    87 15.6 18.5 18.4   4    4    8  0.6946 -1.7101 -0.6946     84\n#> 20010602    NA 17.0 18.4 17.7   5    5    7 -4.3301 -4.0000 -3.0000     87\n#> 20010603    92 15.3 17.6 19.5   2    5    4  2.9544  1.8794  0.5209     82\n#> 20010604   114 16.2 19.7 22.5   1   NA    0  0.9848      NA      NA     92\n#> 20010605    94 17.4 20.5 20.4   8    8    7 -0.5000 -2.9544 -4.3301    114\n#> 20010606    80 17.7 19.8 18.3   6    6    7 -5.6382 -5.0000 -6.0000     NA\n#>           vent pluie\n#> 20010601  Nord   Sec\n#> 20010602  Nord   Sec\n#> 20010603   Est  <NA>\n#> 20010604  <NA>   Sec\n#> 20010605 Ouest   Sec\n#> 20010606 Ouest Pluie\n```\n:::\n\n\nY vamos a usar como variable de grupo `vent` y vemos que tenemos por ejemplo paara la segunda fila valores perdidos en la variable numérica `maxO3` o para la tercer fila tenemos un valor perdido para la variable categórica `pluie`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozone[c('20010602','20010603'), ]\n#>          maxO3   T9  T12  T15 Ne9 Ne12 Ne15     Vx9    Vx12    Vx15 maxO3v vent\n#> 20010602    NA 17.0 18.4 17.7   5    5    7 -4.3301 -4.0000 -3.0000     87 Nord\n#> 20010603    92 15.3 17.6 19.5   2    5    4  2.9544  1.8794  0.5209     82  Est\n#>          pluie\n#> 20010602   Sec\n#> 20010603  <NA>\n```\n:::\n\n\nPara aplicar el método de imputación tenemos que decidir qué número de componentes queremos para la estructura general y cuántos para la particular. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# en ifac tenemos que poner el índice de la variable de grupo (de tipo factor), vent es la 12\nncp_estim <- estim_ncpMultilevel(ozone, ifac = 12)\n```\n:::\n\n\nY  nos devuelve el número de componentes estimados entre los grupos `ncpB` y el número de componentes estimados dentro de los grupos. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nncp_estim$ncpB\n#> [1] 1\nncp_estim$ncpW\n#> [1] 3\n```\n:::\n\n\nY con esto se lo pasamos a la función `imputeMultilevel` y hacemos la imputación\n\n\n::: {.cell}\n\n```{.r .cell-code}\nozone_multilevel_imp <-  imputeMultilevel(ozone, ifac = 12, ncpB = 1, ncpW= 3)\n```\n:::\n\n\nY podemos ver la imputación que ha realizado\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ozone_multilevel_imp$completeObs)\n#>             maxO3   T9  T12  T15 Ne9 Ne12 Ne15     Vx9    Vx12    Vx15\n#> 20010601 87.00000 15.6 18.5 18.4   4    4    8  0.6946 -1.7101 -0.6946\n#> 20010602 79.51042 17.0 18.4 17.7   5    5    7 -4.3301 -4.0000 -3.0000\n#> 20010603 92.00000 15.3 17.6 19.5   2    5    4  2.9544  1.8794  0.5209\n#> 20010605 94.00000 17.4 20.5 20.4   8    8    7 -0.5000 -2.9544 -4.3301\n#> 20010606 80.00000 17.7 19.8 18.3   6    6    7 -5.6382 -5.0000 -6.0000\n#> 20010607 68.07716 16.8 15.6 14.9   7    8    8 -4.3301 -1.8794 -3.7588\n#>             maxO3v  vent pluie\n#> 20010601  84.00000  Nord   Sec\n#> 20010602  87.00000  Nord   Sec\n#> 20010603  82.00000   Est   Sec\n#> 20010605 114.00000 Ouest   Sec\n#> 20010606  75.52026 Ouest Pluie\n#> 20010607  80.00000 Ouest   Sec\n```\n:::\n\n\nY vemos que ha realizado tanto imputación de la variable numérica `maxO3` para el dato de 20010602, como imputación de la variable categórica `pluie` para el datos de 20010603\n\n::: {.cell}\n\n```{.r .cell-code}\nozone_multilevel_imp$completeObs[c('20010602','20010603'), c(\"maxO3\", \"pluie\") ]\n#>             maxO3 pluie\n#> 20010602 79.51042   Sec\n#> 20010603 92.00000   Sec\n```\n:::\n\n\nLo dicho, me parece una técnica interesante cuándo se tiene por ejemplo una variable que te clasifica los clientes (ya sea una clasificación previa o dada por negocio) y tenemos datos faltantes tanto para variables numéricas como categóricas. Me parece una mejor solución que imputar por la media, mediana o simplemente asignar un valor pseudo aleatorio tipo -9999. Además de que el enfoque geométrico-algebraico de las técnicas de componentes principales siempre me ha gustado. \n\nY como decía al principio _Quien renuncia a la estructura, deja dinero encima de la mesa._ \n\nFeliz semana. \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../../site_libs/htmlwidgets-1.5.4/htmlwidgets.js\"></script>\n<link href=\"../../../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../../../site_libs/datatables-binding-0.26/datatables.js\"></script>\n<script src=\"../../../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../../../site_libs/dt-core-1.12.1/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../../../site_libs/dt-core-1.12.1/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../../../site_libs/dt-core-1.12.1/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}