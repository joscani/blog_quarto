{
  "hash": "29c0efb5fcc251f684416e8228b2426d",
  "result": {
    "markdown": "---\ntitle: 'Palabras para Julia ( Parte 1/n) '\ndate: '2021-08-07'\nslug: palabras-para-julia-parte-1-n\ncategories:\n  - Julia\n  - ciencia de datos\n  - software\n  - 2021\ndescription: ''\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\n    code-fold: show\n    code-summary: \"Mostrar / ocultar código\"\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n---\n\n\n\n\nA pesar del título, no voy a hablar sobre la excelente canción de [los Suaves](https://youtu.be/WowU0UKaPyE), sino del lenguaje de programación [Julia](https://julialang.org/). Ya en otra entrada del [blog](https://muestrear-no-es-pecado.netlify.app/2019/03/06/glmer-vs-julia-vs-inla/) de hace un par de años comparé `glmer` con `INLA` y la librería `MixedModels`. Por aquel entonces la versión de Julia era la 1.0.3, ya va por la 1.6.2. Debido a reciente entrada de [Carlos](https://www.datanalytics.com/2021/07/14/mi-apuesta-para-el-larguisimo-plazo-julia/) dónde apostaba por Julia para el larguísimo plazo, he decidido echarle un vistazo un poco más en profundidad. \n\nLo cierto es que me está gustando bastante el lenguaje y voy a escribir un par de entradas dónde contar alguna cosilla. Ya Carlos mencionaba que Julia corre sobre [LLVM](https://en.wikipedia.org/wiki/LLVM), pero también cabe mencionar que Julia tiene características más que interesantes, como multiple dispatch o tipos abstractos que permiten al desarrollador escribir código sin preocuparse demasiado por el tipado y que sea el compilador el que cree los métodos específicos. Si, has oído bien, Julia compila las funciones, por lo que tiene la doble ventaja de ser un lenguaje rápido a la vez que sencillo, bueno, su lema dice \"Tan fácil como Python, tan rápido como C\". \n\nEn esta primera entrada voy a poner un ejemplo sencillo de cómo sería hacer un modelo de \"Machín Lenin\" utilizando la librería [`MLJ`](https://github.com/alan-turing-institute/MLJ.jl), y en el post siguiente os contaré como tener un binario para predecir usando ese modelo de forma que funcione en cualquier Linux sin importar si está basado en `Debian`, `Centos` o lo que sea, y sin necesidad de tener instalado Julia, ni docker, ni nada. \n\n\n## Modelo con MLJ \n\nMLJ es una librería que pretende servir de interfaz común a otras muchas librerías. Veamos un ejemplo de como ajustar un `RandomForest` implementado en la librería `DecisionTree`. \n\nLo primero, para instalar paquetes podéis mirar [esto](http://pkgdocs.julialang.org/latest/getting-started/), básicamente haces \n\n```julia\nusing Pkg\nPkg.import(\"nombre_paquete\")\n\n```\n\nO en el REPL de Julia entras en el modo Package pulsando `]`  y pones `add nombre_paquete` . Esto bajará la librería correspondiente precompilado y la añade a `~/.julia/packages/` \n\nVamos al ejemplo. Aunque voy a usar chunks de julia (gracias a la librería JuliaCall) en el rmarkdown dónde escribo los posts, en realidad como editor par Julia me gusta VSCode. \n\nLos datos de ejemplo son de la librería `boot`de R . puedes ver la ayuda haciendo en R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(boot)\nhelp(channing)\n\n```\n:::\n\n\n```\nChanning House Data\nDescription\nThe channing data frame has 462 rows and 5 columns.\n\nChanning House is a retirement centre in Palo Alto, California. These data were collected between the opening of the house in 1964 until July 1, 1975. In that time 97 men and 365 women passed through the centre. For each of these, their age on entry and also on leaving or death was recorded. A large number of the observations were censored mainly due to the resident being alive on July 1, 1975 when the data was collected. Over the time of the study 130 women and 46 men died at Channing House. Differences between the survival of the sexes, taking age into account, was one of the primary concerns of this study.\n\nUsage\nchanning\nFormat\nThis data frame contains the following columns:\n\nsex\nA factor for the sex of each resident (\"Male\" or \"Female\").\n\nentry\nThe residents age (in months) on entry to the centre\n\nexit\nThe age (in months) of the resident on death, leaving the centre or July 1, 1975 whichever event occurred first.\n\ntime\nThe length of time (in months) that the resident spent at Channing House. (time=exit-entry)\n\ncens\nThe indicator of right censoring. 1 indicates that the resident died at Channing House, 0 indicates that they left the house prior to July 1, 1975 or that they were still alive and living in the centre at that date.\n\n```\n\nEn Julia podemos instalar la librería `RDatasets` y usar esos datos\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing RDatasets, MLJ\nchanning = dataset(\"boot\", \"channing\")\n#> 462×5 DataFrame\n#>  Row │ Sex     Entry  Exit   Time   Cens\n#>      │ Cat…    Int32  Int32  Int32  Int32\n#> ─────┼────────────────────────────────────\n#>    1 │ Male      782    909    127      1\n#>    2 │ Male     1020   1128    108      1\n#>    3 │ Male      856    969    113      1\n#>    4 │ Male      915    957     42      1\n#>    5 │ Male      863    983    120      1\n#>    6 │ Male      906   1012    106      1\n#>    7 │ Male      955   1055    100      1\n#>    8 │ Male      943   1025     82      1\n#>   ⋮  │   ⋮       ⋮      ⋮      ⋮      ⋮\n#>  456 │ Female    986   1030     44      1\n#>  457 │ Female   1039   1132     93      1\n#>  458 │ Female    968    990     22      1\n#>  459 │ Female    955    990     35      1\n#>  460 │ Female    837    911     74      1\n#>  461 │ Female    861    915     54      1\n#>  462 │ Female    967    983     16      1\n#>                           447 rows omitted\n```\n:::\n\n\n\nMLJ necesita que las columnas tenga los tipos correctos en [`scitypes`](https://github.com/JuliaAI/ScientificTypes.jl). Podemos verlos con \n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nschema(channing)\n#> ┌─────────┬─────────────────────────────────┬───────────────┐\n#> │ _.names │ _.types                         │ _.scitypes    │\n#> ├─────────┼─────────────────────────────────┼───────────────┤\n#> │ Sex     │ CategoricalValue{String, UInt8} │ Multiclass{2} │\n#> │ Entry   │ Int32                           │ Count         │\n#> │ Exit    │ Int32                           │ Count         │\n#> │ Time    │ Int32                           │ Count         │\n#> │ Cens    │ Int32                           │ Count         │\n#> └─────────┴─────────────────────────────────┴───────────────┘\n#> _.nrows = 462\n```\n:::\n\n\nQueremos modelar la variable `exit`. `MLJ` quiere la `y` por un lado y las X's por otro, para eso vamos a usar la función `unpack` que además de permitir eso permite cambiar el tipo de las variables, y convertir la variable Cens a categórica por ejemplo\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ny, X =  unpack(channing,\n                      ==(:Exit),            # con el doble igual seleccionamos la y\n                      !=(:Time);            # Quitamos variable Time\n                      :Exit=>Continuous,    # Convertimos al tipo correcto en scitypes\n                      :Entry=>Continuous,\n                      :Cens=>Multiclass)\n#> ([909.0, 1128.0, 969.0, 957.0, 983.0, 1012.0, 1055.0, 1025.0, 1043.0, 945.0  …  905.0, 1040.0, 926.0, 1030.0, 1132.0, 990.0, 990.0, 911.0, 915.0, 983.0], 462×3 DataFrame\n#>  Row │ Sex     Entry    Cens\n#>      │ Cat…    Float64  Cat…\n#> ─────┼───────────────────────\n#>    1 │ Male      782.0  1\n#>    2 │ Male     1020.0  1\n#>    3 │ Male      856.0  1\n#>    4 │ Male      915.0  1\n#>    5 │ Male      863.0  1\n#>    6 │ Male      906.0  1\n#>    7 │ Male      955.0  1\n#>    8 │ Male      943.0  1\n#>   ⋮  │   ⋮        ⋮      ⋮\n#>  456 │ Female    986.0  1\n#>  457 │ Female   1039.0  1\n#>  458 │ Female    968.0  1\n#>  459 │ Female    955.0  1\n#>  460 │ Female    837.0  1\n#>  461 │ Female    861.0  1\n#>  462 │ Female    967.0  1\n#>              447 rows omitted)\n```\n:::\n\n\nAhora ya podemos ver como se hace el modelo. \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nTree = @load RandomForestRegressor pkg=DecisionTree\n#> import MLJDecisionTreeInterface ✔\n#> MLJDecisionTreeInterface.RandomForestRegressor\ntree = Tree(n_trees = 20) # tambien se puede instanciar sin paraámetros \n#> RandomForestRegressor(\n#>     max_depth = -1,\n#>     min_samples_leaf = 1,\n#>     min_samples_split = 2,\n#>     min_purity_increase = 0.0,\n#>     n_subfeatures = -1,\n#>     n_trees = 20,\n#>     sampling_fraction = 0.7,\n#>     pdf_smoothing = 0.0,\n#>     rng = Random._GLOBAL_RNG())\u001b[34m @366\u001b[39m\n# y usar tree.n_trees = 20\n\n```\n:::\n\nComo tenemos la variable `Cens`que es categórica necesitamos codificarla, aquí entra como hacer un pipeline en MLJ, que es una de las cosas más potentes que tiene junto con los [ComposingModels](https://alan-turing-institute.github.io/MLJ.jl/stable/composing_models/) models que permite mezclar varios modelos. \n\n\n::: {.cell}\n\n```{.julia .cell-code}\n# Definimos un ContinuosEncoder, ver la ayuda con ?ContinousEncoder en el repl de julia\n\n  \n\n  # Unsupervised model for arranging all features (columns) of a table to have Continuous element scitype, by applying the following protocol to each feature ftr:\n  # \n  #   •  If ftr is already Continuous retain it.\n  # \n  #   •  If ftr is Multiclass, one-hot encode it.\n  # \n  #   •  If ftr is OrderedFactor, replace it with coerce(ftr, Continuous) (vector of floating point integers), unless ordered_factors=false is specified, in which case\n  #      one-hot encode it.\n  # \n  #   •  If ftr is Count, replace it with coerce(ftr, Continuous).\n  # \n  #   •  If ftr is of some other element scitype, or was not observed in fitting the encoder, drop it from the table.\n  # \n  # If drop_last=true is specified, then one-hot encoding always drops the last class indicator colum\n\nhot = ContinuousEncoder(one_hot_ordered_factors=true, drop_last=true)\n#> ContinuousEncoder(\n#>     drop_last = true,\n#>     one_hot_ordered_factors = true)\u001b[34m @117\u001b[39m\n```\n:::\n\n\nUtilizamos la macro `@pipeline` para encadenar el onehot y el modelo\n\n\n::: {.cell}\n\n```{.julia .cell-code}\npipe = @pipeline hot tree\n#> Pipeline259(\n#>     continuous_encoder = ContinuousEncoder(\n#>             drop_last = true,\n#>             one_hot_ordered_factors = true),\n#>     random_forest_regressor = RandomForestRegressor(\n#>             max_depth = -1,\n#>             min_samples_leaf = 1,\n#>             min_samples_split = 2,\n#>             min_purity_increase = 0.0,\n#>             n_subfeatures = -1,\n#>             n_trees = 20,\n#>             sampling_fraction = 0.7,\n#>             pdf_smoothing = 0.0,\n#>             rng = Random._GLOBAL_RNG()))\u001b[34m @447\u001b[39m\n```\n:::\n\n\nY ya podemos ajustar el modelo por ejemplo utilizando `evaluate` y validación cruzada\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nevaluate(pipe, X, y, resampling=CV(nfolds=5), measure = [rmse, mae])\n#> PerformanceEvaluation object with these fields:\n#>   measure, measurement, operation, per_fold,\n#>   per_observation, fitted_params_per_fold,\n#>   report_per_fold, train_test_pairs\n#> extract:\n#> ┌─────────────────────────────────────────┬─────────────┬───────────┬───────────\n#> │ measure                                 │ measurement │ operation │ per_fold ⋯\n#> ├─────────────────────────────────────────┼─────────────┼───────────┼───────────\n#> │ RootMeanSquaredError()\\e[34m @216\\e[39m │ 54.6        │ predict   │ [47.2, 5 ⋯\n#> │ MeanAbsoluteError()\\e[34m @160\\e[39m    │ 45.9        │ predict   │ [40.1, 5 ⋯\n#> └─────────────────────────────────────────┴─────────────┴───────────┴───────────\n#>                                                                 1 column omitted\n```\n:::\n\n\nHay más medidas que se pueden listar con `measures()`\n\nTambién podemos partir en train, test y similar\n\n\n::: {.cell}\n\n```{.julia .cell-code}\ntrain, test = partition(eachindex(y), 0.7, shuffle=true, rng=155);\n```\n:::\n\n\nAhora instanciamos el modelo con `machine` especificando la X, y la y \n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmodelo = machine(pipe, X,y)\n#> \u001b[34mMachine{Pipeline259,…} @838\u001b[39m trained 0 times; caches data\n#>   args: \n#>     1:\t\u001b[34mSource @987\u001b[39m ⏎ `Table{Union{AbstractVector{Continuous}, AbstractVector{Multiclass{2}}}}`\n#>     2:\t\u001b[34mSource @871\u001b[39m ⏎ `AbstractVector{Continuous}`\n```\n:::\n\nY podemos usar `fit!` para ajustar \"in place\" (en julia si la función acaba en ! es una función que actua modificando el objeto que se le pasa) sin tener que crear otra variable \n\n\n::: {.cell}\n\n```{.julia .cell-code}\n\nfit!(modelo, rows = train)\n#> \u001b[34mMachine{Pipeline259,…} @838\u001b[39m trained 1 time; caches data\n#>   args: \n#>     1:\t\u001b[34mSource @987\u001b[39m ⏎ `Table{Union{AbstractVector{Continuous}, AbstractVector{Multiclass{2}}}}`\n#>     2:\t\u001b[34mSource @871\u001b[39m ⏎ `AbstractVector{Continuous}`\n```\n:::\n\n\nY ya podríamos predecir sobre test, dónde se le aplicaría el onehot encoder que hemos definido en el pipeline\n\n\n::: {.cell}\n\n```{.julia .cell-code}\n# En julia podemos usar sintaxis latex por ejemplo \\beta\\hat  y tabulador despues de beta y hat en vscode \n# escribe β̂ (uso juliaMono https://juliamono.netlify.app/) como tipo de letra \nŷ = predict(modelo,X[test, :])\n#> 139-element Vector{Float64}:\n#>  1060.8833333333334\n#>  1090.125\n#>  1024.5666666666666\n#>  1039.45\n#>   931.9666666666668\n#>   975.8\n#>  1114.1\n#>   966.925\n#>   955.65\n#>   883.3666666666668\n#>     ⋮\n#>   881.6266666666667\n#>   854.2\n#>  1025.0\n#>   919.6333333333332\n#>   932.5\n#>   935.5\n#>  1061.0166666666667\n#>   929.9\n#>   958.9\n```\n:::\n\n\nEn este caso hemos hecho un modelo para predecir una variable continua, cuando sea categórica  existen funciones que devuelven la clase predicha o la probabilidad de cada clase. \n\nTambién podemos ver como varía el error según el número de árboles\n\n\n\n::: {.cell}\n\n```{.julia .cell-code}\nmodelo\n#> \u001b[34mMachine{Pipeline259,…} @838\u001b[39m trained 1 time; caches data\n#>   args: \n#>     1:\t\u001b[34mSource @987\u001b[39m ⏎ `Table{Union{AbstractVector{Continuous}, AbstractVector{Multiclass{2}}}}`\n#>     2:\t\u001b[34mSource @871\u001b[39m ⏎ `AbstractVector{Continuous}`\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nr_tree = range(pipe, :(random_forest_regressor.n_trees), lower=2, upper=20)\n#> typename(MLJBase.NumericRange)(Int64, :(random_forest_regressor.n_trees), ... )\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\n\ncurve = MLJ.learning_curve(modelo;\n                           range=r_tree,\n                           resampling=CV(nfolds=5),\n                           measure=rmse)\n#> (parameter_name = \"random_forest_regressor.n_trees\",\n#>  parameter_scale = :linear,\n#>  parameter_values = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n#>  measurements = [57.62183128809188, 56.51529950303111, 55.56904469933379, 54.8531983408167, 54.847208941367946, 54.444800632308684, 54.81102183981715, 55.012542834615445, 55.06356266514865, 54.88135766866701, 54.44612444179021, 54.773279907824005, 54.59173426290152, 54.23406251166757, 54.3549570009795, 54.14458345130954, 54.34244340416005, 54.43188079909501, 54.62850574226529],)\n```\n:::\n\n::: {.cell}\n\n```{.julia .cell-code}\nusing Plots\ngr() # especificamos un \nplot(curve.parameter_values,\n     curve.measurements,\n     xlab=curve.parameter_name,\n     xscale=curve.parameter_scale,\n     ylab = \"CV estimate of RMSE error\")\n```\n:::\n\n\n\n![plot](plot1.png)\n\nY esto es todo, en el próximo post contaré como crear el binario que nos va a permitir tener un motor de predicción para los modelos de un árbol de decisión y que funcione en cualquier linux. Casi listo para producción (o al menos una parte importante) sin tener que tener julia en dónde se vaya a utilizar. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}