{
  "hash": "eb14b173714e05f6df762d239335e8a0",
  "result": {
    "markdown": "---\ntitle: '¿Dos ejes de ordenadas? (Parte 2/n) '\nauthor: jlcr\ndate: '2021-08-28'\nslug: dos-ejes-de-ordenadas-parte-2-n\ncategories:\n  - gráficos\n  - 2021\nexecute: \n  message: false\n  warning: false\n  echo: true\nformat: \n  html: \n    fig-height: 5\n    fig-dpi: 300\n    fig-width: 8.88\n    fig-align: center\nknitr:\n  opts_chunk:\n    out.width: 80%\n    fig.showtext: TRUE\n    collapse: true\n    comment: \"#>\"\n\n---\n\n\n\n\nSiguiendo con el tema de los dos ejes de ordenadas, a mi no me gustan especialmente este tipo de gráficos,  pero puedo entender que se use y,  cómo dice mi amigo [Raúl Vaquerizo](https://analisisydecision.es/), lo importante es que se entienda. \n\n\nVeamos un ejemplo que nos comentó [Jesús Lagos](https://twitter.com/Vdot_Spain) dónde se suele aplicar este tipo de gráficos, se trata de los climogramas, dónde se presentan en el eje X los meses del año y en los dos ejes de ordenadas la precipitación y la temperatura.\n\n\nVeamos unos datos de Madrid en 2018, extraídos de [aquí](https://www.tutiempo.net/clima/climograma-2018/ws-82210.html). Y veamos como queda en R.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(patchwork)\n```\n:::\n\n\nLeemos los datos , que son estos.\n\n```\nMes,T,PP\nEnero,5.9,30.48\nFebrero,5.4,44.19\nMarzo,8.9,143.49\nAbril,13,57.67\nMayo,16.6,57.93\nJunio,22.2,32.75\nJulio,26.1,2.03\nAgosto,27.5,1.02\nSeptiembre,23.9,4.07\nOctubre,15.1,72.64\nNoviembre,9.9,54.07\nDiciembre,6,9.14\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmad <- read.csv(\"climograma_mad\")\nmad$Mes <- as_factor(mad$Mes)\n```\n:::\n\n\nY pintamos un gráfico de dos ejes de ordenadas. Es importante elegir la transformación que le hacemos a la segunda variable \"y\" para que se pueda representar bien, al fin y al cabo se pinta en un sistema de coordenadas y tenemos que poner ambas variables en escala parecida.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nmulti <- 2\n\nggplot(mad, aes(x = Mes)) +\n  geom_col(aes(y = PP), fill = \"yellow\", alpha = 0.7) +\n  geom_line(aes(y = T * multi), group = 1, color = \"red\") +\n  geom_text(\n    aes(y = T * multi, label = paste(round(T, 1))),\n    vjust = 1.4,\n    color = \"darkred\"\n  ) +\n  scale_y_continuous(sec.axis = sec_axis(~ . / multi,\n    name = \"Temperatura\"\n  )) +\n  theme(\n    axis.title.y.right = element_text(\n      color = \"darkred\",\n      hjust = 0.01\n    ),\n    axis.text.y.right = element_text(\n      face = \"bold\",color = \"darkred\" )\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=80%}\n:::\n:::\n\n\nY la verdad es que eligiendo un factor de 2 podemos distorsionar el gráfico. Por convención lo que se suele hacer es considerar un factor que haga que al pintar en el sistema de referencia los máximos de ambas variables coincidan. Ya que este tipo de gráficos \"mapea\" dos variables al mismo \"aesthetics\", se necesita hacer esa transformación para equiparar las variables. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti <- max(mad$PP) / max(mad$T)\n\nggplot(mad, aes(x = Mes)) +\n  geom_col(aes(y = PP), fill = \"yellow\", alpha = 0.7) +\n  geom_line(aes(y = T * multi), group = 1, color = \"red\") +\n  geom_text(\n    aes(y = T * multi, label = paste(round(T, 1))),\n    vjust = 1.4,\n    color = \"darkred\"\n  ) +\n  scale_y_continuous(\n    name = \"Precipitaciones\",\n    # segundo eje\n    sec.axis = sec_axis(~ . / multi,\n      name = \"Temperatura\"\n    )\n  ) +\n  theme(\n    axis.title.y.right = element_text(\n      color = \"darkred\",\n      hjust = 0.01\n    ),\n    axis.text.y.right = element_text(\n      face = \"bold\", color = \"darkred\"\n    )\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=80%}\n:::\n:::\n\nY bueno, no queda mal del todo, aunque Tufte me mataría por esto. \n\nYo en realidad habría hecho algo como esto. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- mad %>% \n  ggplot(aes(x = Mes, y = T)) +\n  geom_point() + \n  geom_path(group=1) +\n  labs(title = \"Temperatura\")\n\np2 <- mad %>% \n  ggplot(aes(x = Mes, y = PP)) +\n  geom_col() +\n  labs(title = \"Precipitaciones\")\n\np1 / p2\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=80%}\n:::\n:::\n\n\nY si acaso, para ver la relación entre Precipitaciones y Temperatura, pues algo así.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mad,aes(x = T, y = PP)) + \n  geom_point() +\n  ggrepel::geom_label_repel(aes(label = Mes), size = 3) +\n  geom_smooth() +\n  labs(title = \"Precipitaciones ~ Temperatura\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=80%}\n:::\n:::\n\n\nY bueno, poco más que decir, siguen sin gustarme los gráficos de dos ejes de ordenadas, puede que por cuestiones filosóficas de no asignar dos variables distintas a mismo \"aesthetic\". \n\nHasta otro día. \n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}